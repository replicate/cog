{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Cog: Containers for machine learning","text":"<p>Cog is an open-source tool that lets you package machine learning models in a standard, production-ready container.</p> <p>You can deploy your packaged model to your own infrastructure, or to Replicate.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li> <p>\ud83d\udce6 Docker containers without the pain. Writing your own <code>Dockerfile</code> can be a bewildering process. With Cog, you define your environment with a simple configuration file and it generates a Docker image with all the best practices: Nvidia base images, efficient caching of dependencies, installing specific Python versions, sensible environment variable defaults, and so on.</p> </li> <li> <p>\ud83e\udd2c\ufe0f No more CUDA hell. Cog knows which CUDA/cuDNN/PyTorch/Tensorflow/Python combos are compatible and will set it all up correctly for you.</p> </li> <li> <p>\u2705 Define the inputs and outputs for your model with standard Python. Then, Cog generates an OpenAPI schema and validates the inputs and outputs.</p> </li> <li> <p>\ud83c\udf81 Automatic HTTP prediction server: Your model's types are used to dynamically generate a RESTful HTTP API using a high-performance Rust/Axum server.</p> </li> <li> <p>\ud83e\udd5e Automatic queue worker. Long-running deep learning models or batch processing is best architected with a queue. Cog models do this out of the box. Redis is currently supported, with more in the pipeline.</p> </li> <li> <p>\ud83d\ude80 Ready for production. Deploy your model anywhere that Docker images run. Your own infrastructure, or Replicate.</p> </li> </ul>"},{"location":"#how-it-works","title":"How it works","text":"<p>Define the Docker environment your model runs in with <code>cog.yaml</code>:</p> <pre><code>build:\n  gpu: true\n  system_packages:\n    - \"libgl1-mesa-glx\"\n    - \"libglib2.0-0\"\n  python_version: \"3.12\"\n  python_requirements: requirements.txt\npredict: \"predict.py:Predictor\"\n</code></pre> <p>Define how predictions are run on your model with <code>predict.py</code>:</p> <pre><code>from cog import BasePredictor, Input, Path\nimport torch\n\nclass Predictor(BasePredictor):\n    def setup(self):\n        \"\"\"Load the model into memory to make running multiple predictions efficient\"\"\"\n        self.model = torch.load(\"./weights.pth\")\n\n    # The arguments and types the model takes as input\n    def predict(self,\n          image: Path = Input(description=\"Grayscale input image\")\n    ) -&gt; Path:\n        \"\"\"Run a single prediction on the model\"\"\"\n        processed_image = preprocess(image)\n        output = self.model(processed_image)\n        return postprocess(output)\n</code></pre> <p>In the above we accept a path to the image as an input, and return a path to our transformed image after running it through our model.</p> <p>Now, you can run predictions on this model:</p> <pre><code>$ cog predict -i image=@input.jpg\n--&gt; Building Docker image...\n--&gt; Running Prediction...\n--&gt; Output written to output.jpg\n</code></pre> <p>Or, build a Docker image for deployment:</p> <pre><code>$ cog build -t my-classification-model\n--&gt; Building Docker image...\n--&gt; Built my-classification-model:latest\n\n$ docker run -d -p 5000:5000 --gpus all my-classification-model\n\n$ curl http://localhost:5000/predictions -X POST \\\n    -H 'Content-Type: application/json' \\\n    -d '{\"input\": {\"image\": \"https://.../input.jpg\"}}'\n</code></pre> <p>Or, combine build and run via the <code>serve</code> command:</p> <pre><code>$ cog serve -p 8080\n\n$ curl http://localhost:8080/predictions -X POST \\\n    -H 'Content-Type: application/json' \\\n    -d '{\"input\": {\"image\": \"https://.../input.jpg\"}}'\n</code></pre>"},{"location":"#why-are-we-building-this","title":"Why are we building this?","text":"<p>It's really hard for researchers to ship machine learning models to production.</p> <p>Part of the solution is Docker, but it is so complex to get it to work: Dockerfiles, pre-/post-processing, Flask servers, CUDA versions. More often than not the researcher has to sit down with an engineer to get the damn thing deployed.</p> <p>Andreas and Ben created Cog. Andreas used to work at Spotify, where he built tools for building and deploying ML models with Docker. Ben worked at Docker, where he created Docker Compose.</p> <p>We realized that, in addition to Spotify, other companies were also using Docker to build and deploy machine learning models. Uber and others have built similar systems. So, we're making an open source version so other people can do this too.</p> <p>Hit us up if you're interested in using it or want to collaborate with us. We're on Discord or email us at team@replicate.com.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>macOS, Linux or Windows 11. Cog works on macOS, Linux and Windows 11 with WSL 2</li> <li>Docker. Cog uses Docker to create a container for your model. You'll need to install Docker before you can run Cog. If you install Docker Engine instead of Docker Desktop, you will need to install Buildx as well.</li> </ul>"},{"location":"#install","title":"Install","text":"<p>If you're using macOS, you can install Cog using Homebrew:</p> <pre><code>brew install replicate/tap/cog\n</code></pre> <p>You can also download and install the latest release using our  install script:</p> <pre><code># bash, zsh, and other shells\nsh &lt;(curl -fsSL https://cog.run/install.sh)\n\n# fish shell\nsh (curl -fsSL https://cog.run/install.sh | psub)\n\n# download with wget and run in a separate command\nwget -qO- https://cog.run/install.sh\nsh ./install.sh\n</code></pre> <p>You can manually install the latest release of Cog directly from GitHub  by running the following commands in a terminal:</p> <pre><code>sudo curl -o /usr/local/bin/cog -L \"https://github.com/replicate/cog/releases/latest/download/cog_$(uname -s)_$(uname -m)\"\nsudo chmod +x /usr/local/bin/cog\n</code></pre> <p>Or if you are on docker:</p> <pre><code>RUN sh -c \"INSTALL_DIR=\\\"/usr/local/bin\\\" SUDO=\\\"\\\" $(curl -fsSL https://cog.run/install.sh)\"\n</code></pre>"},{"location":"#upgrade","title":"Upgrade","text":"<p>If you're using macOS and you previously installed Cog with Homebrew, run the following:</p> <pre><code>brew upgrade replicate/tap/cog\n</code></pre> <p>Otherwise, you can upgrade to the latest version by running the same commands you used to install it.</p>"},{"location":"#development","title":"Development","text":"<p>See CONTRIBUTING.md for how to set up a development environment and build from source.</p>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Get started with an example model</li> <li>Get started with your own model</li> <li>Using Cog with notebooks</li> <li>Using Cog with Windows 11</li> <li>Take a look at some examples of using Cog</li> <li>Deploy models with Cog</li> <li><code>cog.yaml</code> reference to learn how to define your model's environment</li> <li>Prediction interface reference to learn how the <code>Predictor</code> interface works</li> <li>Training interface reference to learn how to add a fine-tuning API to your model</li> <li>HTTP API reference to learn how to use the HTTP API that models serve</li> </ul>"},{"location":"#need-help","title":"Need help?","text":"<p>Join us in #cog on Discord.</p> <p></p>"},{"location":"#contributors","title":"Contributors \u2728","text":"<p>Thanks goes to these wonderful people (emoji key):</p> <sub>Ben Firshman</sub>\ud83d\udcbb \ud83d\udcd6 <sub>Andreas Jansson</sub>\ud83d\udcbb \ud83d\udcd6 \ud83d\udea7 <sub>Zeke Sikelianos</sub>\ud83d\udcbb \ud83d\udcd6 \ud83d\udd27 <sub>Rory Byrne</sub>\ud83d\udcbb \ud83d\udcd6 \u26a0\ufe0f <sub>Michael Floering</sub>\ud83d\udcbb \ud83d\udcd6 \ud83e\udd14 <sub>Ben Evans</sub>\ud83d\udcd6 <sub>shashank agarwal</sub>\ud83d\udcbb \ud83d\udcd6 <sub>VictorXLR</sub>\ud83d\udcbb \ud83d\udcd6 \u26a0\ufe0f <sub>hung anna</sub>\ud83d\udc1b <sub>Brian Whitman</sub>\ud83d\udc1b <sub>JimothyJohn</sub>\ud83d\udc1b <sub>ericguizzo</sub>\ud83d\udc1b <sub>Dominic Baggott</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Dashiell Stander</sub>\ud83d\udc1b \ud83d\udcbb \u26a0\ufe0f <sub>Shuwei Liang</sub>\ud83d\udc1b \ud83d\udcac <sub>Eric Allam</sub>\ud83e\udd14 <sub>Iv\u00e1n Perdomo</sub>\ud83d\udc1b <sub>Charles Frye</sub>\ud83d\udcd6 <sub>Luan Pham</sub>\ud83d\udc1b \ud83d\udcd6 <sub>TommyDew</sub>\ud83d\udcbb <sub>Jesse Andrews</sub>\ud83d\udcbb \ud83d\udcd6 \u26a0\ufe0f <sub>Nick Stenning</sub>\ud83d\udcbb \ud83d\udcd6 \ud83c\udfa8 \ud83d\ude87 \u26a0\ufe0f <sub>Justin Merrell</sub>\ud83d\udcd6 <sub>Rurik Yl\u00e4-Onnenvuori</sub>\ud83d\udc1b <sub>Youka</sub>\ud83d\udc1b <sub>Clay Mullis</sub>\ud83d\udcd6 <sub>Mattt</sub>\ud83d\udcbb \ud83d\udcd6 \ud83d\ude87 <sub>Eng Zer Jun</sub>\u26a0\ufe0f <sub>BB</sub>\ud83d\udcbb <sub>williamluer</sub>\ud83d\udcd6 <sub>Simon Eskildsen</sub>\ud83d\udcbb <sub>F</sub>\ud83d\udc1b \ud83d\udcbb <sub>Philip Potter</sub>\ud83d\udc1b \ud83d\udcbb <sub>Joanne Chen</sub>\ud83d\udcd6 <sub>technillogue</sub>\ud83d\udcbb <sub>Aron Carroll</sub>\ud83d\udcd6 \ud83d\udcbb \ud83e\udd14 <sub>Bohdan Mykhailenko</sub>\ud83d\udcd6 \ud83d\udc1b <sub>Daniel Radu</sub>\ud83d\udcd6 \ud83d\udc1b <sub>Itay Etelis</sub>\ud83d\udcbb <sub>Gennaro Schiano</sub>\ud83d\udcd6 <sub>Andr\u00e9 Kn\u00f6rig</sub>\ud83d\udcd6 <sub>Dan Fairs</sub>\ud83d\udcbb <p>This project follows the all-contributors specification. Contributions of any kind welcome!</p>"},{"location":"CONTRIBUTING/","title":"Contributing guide","text":""},{"location":"CONTRIBUTING/#development-environment","title":"Development environment","text":"<p>Development tasks are managed with mise. Run <code>mise tasks</code> to see all available tasks.</p>"},{"location":"CONTRIBUTING/#prerequisites","title":"Prerequisites","text":"<ul> <li>mise: Manages Go, Rust, Python, and other tools</li> <li>Docker or OrbStack</li> </ul>"},{"location":"CONTRIBUTING/#setup","title":"Setup","text":"<pre><code># Trust the mise configuration and install tools\nmise trust\nmise install\n\n# Create Python virtualenv and install dependencies\nuv venv\nuv sync --all-groups\n</code></pre>"},{"location":"CONTRIBUTING/#build-install","title":"Build &amp; install","text":"<pre><code>mise run build\n\n# symlink the binary to /usr/local/bin\nsudo mise run install                     \n</code></pre> <p>After making changes, run <code>mise run build</code> to rebuild and it will get picked up by the symlink.</p>"},{"location":"CONTRIBUTING/#common-tasks","title":"Common tasks","text":"<pre><code># Run all tests\nmise run test:go\nmise run test:python\nmise run test:rust\n\n# Run specific tests\nmise run test:go -- ./pkg/config\nuv run tox -e py312-tests -- python/tests/server/test_http.py -k test_name\n\n# Format code (all languages)\nmise run fmt:fix\n\n# Lint code (all languages)\nmise run lint\n</code></pre> <p>Run <code>mise tasks</code> for the complete list of available tasks.</p> <p>If you encounter any errors, see the troubleshooting section below.</p>"},{"location":"CONTRIBUTING/#project-structure","title":"Project structure","text":"<p>As much as possible, this is attempting to follow the Standard Go Project Layout.</p> <ul> <li><code>cmd/</code> - The root <code>cog</code> command.</li> <li><code>pkg/cli/</code> - CLI commands.</li> <li><code>pkg/config</code> - Everything <code>cog.yaml</code> related.</li> <li><code>pkg/docker/</code> - Low-level interface for Docker commands.</li> <li><code>pkg/dockerfile/</code> - Creates Dockerfiles.</li> <li><code>pkg/image/</code> - Creates and manipulates Cog Docker images.</li> <li><code>pkg/predict/</code> - Runs predictions on models.</li> <li><code>pkg/util/</code> - Various packages that aren't part of Cog. They could reasonably be separate re-usable projects.</li> <li><code>python/</code> - The Cog Python library.</li> <li><code>integration-tests/</code> - Go-based integration tests using testscript.</li> <li><code>tools/compatgen/</code> - Tool for generating CUDA/PyTorch/TensorFlow compatibility matrices.</li> </ul> <p>For deeper architectural understanding, see the architecture documentation.</p>"},{"location":"CONTRIBUTING/#updating-compatibility-matrices","title":"Updating compatibility matrices","text":"<p>The CUDA base images and framework compatibility matrices in <code>pkg/config/</code> are checked into source control and only need to be regenerated when adding support for new versions of CUDA, PyTorch, or TensorFlow.</p> <p>To regenerate the compatibility matrices, run:</p> <pre><code># Regenerate all matrices\nmise run generate:compat\n\n# Or regenerate specific matrices\nmise run generate:compat cuda\nmise run generate:compat torch\nmise run generate:compat tensorflow\n</code></pre> <p>The generated files are: - <code>pkg/config/cuda_base_images.json</code> - Available NVIDIA CUDA base images - <code>pkg/config/torch_compatibility_matrix.json</code> - PyTorch/CUDA/Python compatibility - <code>pkg/config/tf_compatibility_matrix.json</code> - TensorFlow/CUDA/Python compatibility</p>"},{"location":"CONTRIBUTING/#ci-tool-dependencies","title":"CI tool dependencies","text":"<p>Development tools are managed in two places that must be kept in sync:</p> <ol> <li><code>mise.toml</code> \u2014 Tool versions for local development (uses aqua backend for prebuilt binaries)</li> <li><code>.github/workflows/ci.yaml</code> \u2014 Tool installation for CI (uses dedicated GitHub Actions)</li> </ol> <p>CI deliberately avoids aqua downloads from GitHub Releases to prevent transient 502 failures. Instead, it uses dedicated actions (<code>taiki-e/install-action</code>, <code>go install</code>, <code>PyO3/maturin-action</code>, etc.) that are more reliable.</p> <p>Tools disabled in CI are listed in <code>MISE_DISABLE_TOOLS</code> in <code>ci.yaml</code>.</p> <p>When updating a tool version, update both: - The version in <code>mise.toml</code> (for local dev) - The corresponding version pin in <code>.github/workflows/ci.yaml</code> (for CI)</p> <p>See the CI Tool Dependencies section in AGENTS.md for the full mapping of tools to their CI installation methods.</p>"},{"location":"CONTRIBUTING/#concepts","title":"Concepts","text":"<p>There are a few concepts used throughout Cog that might be helpful to understand.</p> <ul> <li>Config: The <code>cog.yaml</code> file.</li> <li>Image: Represents a built Docker image that serves the Cog API, containing a model.</li> <li>Input: Input from a prediction, as key/value JSON object.</li> <li>Model: A user's machine learning model, consisting of code and weights.</li> <li>Output: Output from a prediction, as arbitrarily complex JSON object.</li> <li>Prediction: A single run of the model, that takes input and produces output.</li> <li>Predictor: Defines how Cog runs predictions on a model.</li> </ul>"},{"location":"CONTRIBUTING/#running-tests","title":"Running tests","text":"<p>To run the entire test suite:</p> <pre><code>mise run test:go\nmise run test:python\nmise run test:rust\n</code></pre> <p>To run just the Go unit tests:</p> <pre><code>mise run test:go\n</code></pre> <p>To run just the Python tests:</p> <pre><code>mise run test:python\n</code></pre> <p>[!INFO] This runs the Python test suite across all supported Python versions (3.10-3.13) using tox.</p>"},{"location":"CONTRIBUTING/#integration-tests","title":"Integration Tests","text":"<p>Integration tests are in <code>integration-tests/</code> using testscript. Each test is a self-contained <code>.txtar</code> file in <code>integration-tests/tests/</code>, with some specialized tests as Go test functions in subpackages.</p> <pre><code># Run all integration tests\nmise run test:integration\n\n# Run a specific test\nmise run test:integration string_predictor\n\n# Run fast tests only (skip slow GPU/framework tests)\ncd integration-tests &amp;&amp; go test -short -v\n\n# Run with a custom cog binary\nCOG_BINARY=/path/to/cog mise run test:integration\n</code></pre>"},{"location":"CONTRIBUTING/#writing-integration-tests","title":"Writing Integration Tests","text":"<p>When adding new functionality, add integration tests in <code>integration-tests/tests/</code>. They are: - Self-contained (embedded fixtures in <code>.txtar</code> files) - Faster to run (parallel execution with automatic cleanup) - Easier to read and write (simple command script format)</p> <p>Example test structure:</p> <pre><code># Test string predictor\ncog build -t $TEST_IMAGE\ncog predict $TEST_IMAGE -i s=world\nstdout 'hello world'\n\n-- cog.yaml --\nbuild:\n  python_version: \"3.12\"\npredict: \"predict.py:Predictor\"\n\n-- predict.py --\nfrom cog import BasePredictor\n\nclass Predictor(BasePredictor):\n    def predict(self, s: str) -&gt; str:\n        return \"hello \" + s\n</code></pre> <p>For testing <code>cog serve</code>, use <code>cog serve</code> and the <code>curl</code> command:</p> <pre><code>cog build -t $TEST_IMAGE\ncog serve\ncurl POST /predictions '{\"input\":{\"s\":\"test\"}}'\nstdout '\"output\":\"hello test\"'\n</code></pre>"},{"location":"CONTRIBUTING/#advanced-test-commands","title":"Advanced Test Commands","text":"<p>For tests that require subprocess initialization or async operations, use <code>retry-curl</code>:</p> <p><code>retry-curl</code> - HTTP request with automatic retries:</p> <pre><code># Make HTTP request with retry logic (useful for subprocess initialization delays)\n# retry-curl [method] [path] [body] [max-attempts] [retry-delay]\nretry-curl POST /predictions '{\"input\":{\"s\":\"test\"}}' 30 1s\nstdout '\"output\":\"hello test\"'\n</code></pre> <p>Example: Testing predictor with subprocess in setup</p> <pre><code>cog build -t $TEST_IMAGE\ncog serve\n\n# Use generous retries since setup spawns a background process\nretry-curl POST /predictions '{\"input\":{\"s\":\"test\"}}' 30 1s\nstdout '\"output\":\"hello test\"'\n\n-- predict.py --\nclass Predictor(BasePredictor):\n    def setup(self):\n        self.process = subprocess.Popen([\"./background.sh\"])\n\n    def predict(self, s: str) -&gt; str:\n        return \"hello \" + s\n</code></pre>"},{"location":"CONTRIBUTING/#test-conditions","title":"Test Conditions","text":"<p>Use conditions to control when tests run based on environment:</p> <p><code>[short]</code> - Skip slow tests in short mode:</p> <pre><code>[short] skip 'requires GPU or long build time'\n\ncog build -t $TEST_IMAGE\n# ... rest of test\n</code></pre> <p>Run with <code>go test -short</code> to skip these tests.</p> <p><code>[linux]</code> / <code>[!linux]</code> - Platform-specific tests:</p> <pre><code>[!linux] skip 'requires Linux'\n\n# Linux-specific test\ncog build -t $TEST_IMAGE\n</code></pre> <p><code>[amd64]</code> / <code>[!amd64]</code> - Architecture-specific tests:</p> <pre><code>[!amd64] skip 'requires amd64 architecture'\n\n# amd64-specific test\ncog build -t $TEST_IMAGE\n</code></pre> <p><code>[linux_amd64]</code> - Combined platform and architecture:</p> <pre><code>[!linux_amd64] skip 'requires Linux on amd64'\n\n# Test that requires both Linux and amd64\ncog build -t $TEST_IMAGE\n</code></pre> <p>Combining conditions:</p> <p>Conditions can be negated with <code>!</code>. Examples: - <code>[short]</code> - True when <code>go test -short</code> is used (skip this test in short mode) - <code>[!short]</code> - True when NOT running with <code>-short</code> flag (only run this in full test mode) - <code>[!linux]</code> - True when NOT on Linux - <code>[linux_amd64]</code> - True when on Linux AND amd64</p> <p>See existing tests in <code>integration-tests/tests/</code>, especially <code>setup_subprocess_*.txtar</code>, for more examples.</p>"},{"location":"CONTRIBUTING/#running-the-docs-server","title":"Running the docs server","text":"<p>To run the docs website server locally:</p> <pre><code>mise run docs:serve\n</code></pre>"},{"location":"CONTRIBUTING/#publishing-a-release","title":"Publishing a release","text":"<p>Releases are managed by GitHub Actions workflows. See <code>.github/workflows/README.md</code> for full details.</p> <p>All packages use lockstep versioning from <code>crates/Cargo.toml</code>. There are three release types:</p> Type Example tag Branch rule PyPI/crates.io? Stable <code>v0.17.0</code> Must be on main Yes Pre-release <code>v0.17.0-alpha3</code> Must be on main Yes Dev <code>v0.17.0-dev1</code> Any branch No"},{"location":"CONTRIBUTING/#stable-pre-release","title":"Stable / Pre-release","text":"<pre><code># 1. Update crates/Cargo.toml version (e.g. \"0.17.0\" or \"0.17.0-alpha3\")\n# 2. Merge to main\n# 3. Tag and push\ngit tag v0.17.0\ngit push origin v0.17.0\n# 4. Wait for release-build.yaml to create a draft release\n# 5. Review the draft in GitHub UI, then click \"Publish release\"\n#    This triggers release-publish.yaml -&gt; PyPI + crates.io\n</code></pre>"},{"location":"CONTRIBUTING/#dev-release","title":"Dev release","text":"<pre><code># From any branch:\n# 1. Update crates/Cargo.toml version (e.g. \"0.17.0-dev1\")\n# 2. Commit and push\n# 3. Tag and push\ngit tag v0.17.0-dev1\ngit push origin v0.17.0-dev1\n# 4. Done. Artifacts are built and published as a GH pre-release.\n#    No PyPI/crates.io. No manual approval.\n</code></pre>"},{"location":"CONTRIBUTING/#troubleshooting","title":"Troubleshooting","text":""},{"location":"CONTRIBUTING/#cog-command-not-found","title":"<code>cog command not found</code>","text":"<p>The compiled <code>cog</code> binary will be installed in <code>$GOPATH/bin/cog</code>, e.g. <code>~/go/bin/cog</code>. Make sure that Golang's bin directory is present on your system PATH by adding it to your shell config (<code>.bashrc</code>, <code>.zshrc</code>, etc):</p> <pre><code>export PATH=~/go/bin:$PATH\n</code></pre> <p>Still having trouble? Please open an issue on GitHub.</p>"},{"location":"cli/","title":"CLI reference","text":""},{"location":"cli/#cog","title":"<code>cog</code>","text":"<p>Containers for machine learning.</p> <p>To get started, take a look at the documentation: https://github.com/replicate/cog</p> <p>Examples</p> <pre><code>   To run a command inside a Docker environment defined with Cog:\n      $ cog run echo hello world\n</code></pre> <p>Options</p> <pre><code>      --debug     Show debugging output\n  -h, --help      help for cog\n      --version   Show version of Cog\n</code></pre>"},{"location":"cli/#cog-build","title":"<code>cog build</code>","text":"<p>Build a Docker image from the cog.yaml in the current directory.</p> <p>The generated image contains your model code, dependencies, and the Cog runtime. It can be run locally with 'cog predict' or pushed to a registry with 'cog push'.</p> <pre><code>cog build [flags]\n</code></pre> <p>Examples</p> <pre><code>  # Build with default settings\n  cog build\n\n  # Build and tag the image\n  cog build -t my-model:latest\n\n  # Build without using the cache\n  cog build --no-cache\n\n  # Build with model weights in a separate layer\n  cog build --separate-weights -t my-model:v1\n</code></pre> <p>Options</p> <pre><code>  -f, --file string                  The name of the config file. (default \"cog.yaml\")\n  -h, --help                         help for build\n      --no-cache                     Do not use cache when building the image\n      --openapi-schema string        Load OpenAPI schema from a file\n      --progress string              Set type of build progress output, 'auto' (default), 'tty', 'plain', or 'quiet' (default \"auto\")\n      --secret stringArray           Secrets to pass to the build environment in the form 'id=foo,src=/path/to/file'\n      --separate-weights             Separate model weights from code in image layers\n  -t, --tag string                   A name for the built image in the form 'repository:tag'\n      --use-cog-base-image           Use pre-built Cog base image for faster cold boots (default true)\n      --use-cuda-base-image string   Use Nvidia CUDA base image, 'true' (default) or 'false' (use python base image). False results in a smaller image but may cause problems for non-torch projects (default \"auto\")\n</code></pre>"},{"location":"cli/#cog-init","title":"<code>cog init</code>","text":"<p>Create a cog.yaml and predict.py in the current directory.</p> <p>These files provide a starting template for defining your model's environment and prediction interface. Edit them to match your model's requirements.</p> <pre><code>cog init [flags]\n</code></pre> <p>Examples</p> <pre><code>  # Set up a new Cog project in the current directory\n  cog init\n</code></pre> <p>Options</p> <pre><code>  -h, --help   help for init\n</code></pre>"},{"location":"cli/#cog-login","title":"<code>cog login</code>","text":"<p>Log in to a container registry.</p> <p>For Replicate's registry (r8.im), this command handles authentication through Replicate's token-based flow.</p> <p>For other registries, this command prompts for username and password, then stores credentials using Docker's credential system.</p> <pre><code>cog login [flags]\n</code></pre> <p>Options</p> <pre><code>  -h, --help          help for login\n      --token-stdin   Pass login token on stdin instead of opening a browser. You can find your Replicate login token at https://replicate.com/auth/token\n</code></pre>"},{"location":"cli/#cog-predict","title":"<code>cog predict</code>","text":"<p>Run a prediction.</p> <p>If 'image' is passed, it will run the prediction on that Docker image. It must be an image that has been built by Cog.</p> <p>Otherwise, it will build the model in the current directory and run the prediction on that.</p> <pre><code>cog predict [image] [flags]\n</code></pre> <p>Examples</p> <pre><code>  # Run a prediction with named inputs\n  cog predict -i prompt=\"a photo of a cat\"\n\n  # Pass a file as input\n  cog predict -i image=@photo.jpg\n\n  # Save output to a file\n  cog predict -i image=@input.jpg -o output.png\n\n  # Pass multiple inputs\n  cog predict -i prompt=\"sunset\" -i width=1024 -i height=768\n\n  # Run against a pre-built image\n  cog predict r8.im/your-username/my-model -i prompt=\"hello\"\n\n  # Pass inputs as JSON\n  echo '{\"prompt\": \"a cat\"}' | cog predict --json @-\n</code></pre> <p>Options</p> <pre><code>  -e, --env stringArray              Environment variables, in the form name=value\n  -f, --file string                  The name of the config file. (default \"cog.yaml\")\n      --gpus docker run --gpus       GPU devices to add to the container, in the same format as docker run --gpus.\n  -h, --help                         help for predict\n  -i, --input stringArray            Inputs, in the form name=value. if value is prefixed with @, then it is read from a file on disk. E.g. -i path=@image.jpg\n      --json string                  Pass inputs as JSON object, read from file (@inputs.json) or via stdin (@-)\n  -o, --output string                Output path\n      --progress string              Set type of build progress output, 'auto' (default), 'tty', 'plain', or 'quiet' (default \"auto\")\n      --setup-timeout uint32         The timeout for a container to setup (in seconds). (default 300)\n      --use-cog-base-image           Use pre-built Cog base image for faster cold boots (default true)\n      --use-cuda-base-image string   Use Nvidia CUDA base image, 'true' (default) or 'false' (use python base image). False results in a smaller image but may cause problems for non-torch projects (default \"auto\")\n      --use-replicate-token          Pass REPLICATE_API_TOKEN from local environment into the model context\n</code></pre>"},{"location":"cli/#cog-push","title":"<code>cog push</code>","text":"<p>Build a Docker image from cog.yaml and push it to a container registry.</p> <p>Cog can push to any OCI-compliant registry. When pushing to Replicate's registry (r8.im), run 'cog login' first to authenticate.</p> <pre><code>cog push [IMAGE] [flags]\n</code></pre> <p>Examples</p> <pre><code>  # Push to Replicate\n  cog push r8.im/your-username/my-model\n\n  # Push to any OCI registry\n  cog push registry.example.com/your-username/model-name\n\n  # Push with model weights in a separate layer (Replicate only)\n  cog push r8.im/your-username/my-model --separate-weights\n</code></pre> <p>Options</p> <pre><code>  -f, --file string                  The name of the config file. (default \"cog.yaml\")\n  -h, --help                         help for push\n      --no-cache                     Do not use cache when building the image\n      --openapi-schema string        Load OpenAPI schema from a file\n      --progress string              Set type of build progress output, 'auto' (default), 'tty', 'plain', or 'quiet' (default \"auto\")\n      --secret stringArray           Secrets to pass to the build environment in the form 'id=foo,src=/path/to/file'\n      --separate-weights             Separate model weights from code in image layers\n      --use-cog-base-image           Use pre-built Cog base image for faster cold boots (default true)\n      --use-cuda-base-image string   Use Nvidia CUDA base image, 'true' (default) or 'false' (use python base image). False results in a smaller image but may cause problems for non-torch projects (default \"auto\")\n</code></pre>"},{"location":"cli/#cog-run","title":"<code>cog run</code>","text":"<p>Run a command inside a Docker environment defined by cog.yaml.</p> <p>Cog builds a temporary image from your cog.yaml configuration and runs the given command inside it. This is useful for debugging, running scripts, or exploring the environment your model will run in.</p> <pre><code>cog run &lt;command&gt; [arg...] [flags]\n</code></pre> <p>Examples</p> <pre><code>  # Open a Python interpreter inside the model environment\n  cog run python\n\n  # Run a script\n  cog run python train.py\n\n  # Run with environment variables\n  cog run -e HUGGING_FACE_HUB_TOKEN=abc123 python download.py\n\n  # Expose a port (e.g. for Jupyter)\n  cog run -p 8888 jupyter notebook\n</code></pre> <p>Options</p> <pre><code>  -e, --env stringArray              Environment variables, in the form name=value\n  -f, --file string                  The name of the config file. (default \"cog.yaml\")\n      --gpus docker run --gpus       GPU devices to add to the container, in the same format as docker run --gpus.\n  -h, --help                         help for run\n      --progress string              Set type of build progress output, 'auto' (default), 'tty', 'plain', or 'quiet' (default \"auto\")\n  -p, --publish stringArray          Publish a container's port to the host, e.g. -p 8000\n      --use-cog-base-image           Use pre-built Cog base image for faster cold boots (default true)\n      --use-cuda-base-image string   Use Nvidia CUDA base image, 'true' (default) or 'false' (use python base image). False results in a smaller image but may cause problems for non-torch projects (default \"auto\")\n</code></pre>"},{"location":"cli/#cog-serve","title":"<code>cog serve</code>","text":"<p>Run a prediction HTTP server.</p> <p>Builds the model and starts an HTTP server that exposes the model's inputs and outputs as a REST API. Compatible with the Cog HTTP protocol.</p> <pre><code>cog serve [flags]\n</code></pre> <p>Examples</p> <pre><code>  # Start the server on the default port (8393)\n  cog serve\n\n  # Start on a custom port\n  cog serve -p 5000\n\n  # Test the server\n  curl http://localhost:8393/predictions \\\n    -X POST \\\n    -H 'Content-Type: application/json' \\\n    -d '{\"input\": {\"prompt\": \"a cat\"}}'\n</code></pre> <p>Options</p> <pre><code>  -f, --file string                  The name of the config file. (default \"cog.yaml\")\n      --gpus docker run --gpus       GPU devices to add to the container, in the same format as docker run --gpus.\n  -h, --help                         help for serve\n  -p, --port int                     Port on which to listen (default 8393)\n      --progress string              Set type of build progress output, 'auto' (default), 'tty', 'plain', or 'quiet' (default \"auto\")\n      --upload-url string            Upload URL for file outputs (e.g. https://example.com/upload/)\n      --use-cog-base-image           Use pre-built Cog base image for faster cold boots (default true)\n      --use-cuda-base-image string   Use Nvidia CUDA base image, 'true' (default) or 'false' (use python base image). False results in a smaller image but may cause problems for non-torch projects (default \"auto\")\n</code></pre>"},{"location":"deploy/","title":"Deploy models with Cog","text":"<p>Cog containers are Docker containers that serve an HTTP server  for running predictions on your model.  You can deploy them anywhere that Docker containers run.</p> <p>This guide assumes you have a model packaged with Cog.  If you don't, follow our getting started guide,  or use an example model.</p>"},{"location":"deploy/#getting-started","title":"Getting started","text":"<p>First, build your model:</p> <pre><code>cog build -t my-model\n</code></pre> <p>Then, start the Docker container:</p> <pre><code># If your model uses a CPU:\ndocker run -d -p 5001:5000 my-model\n\n# If your model uses a GPU:\ndocker run -d -p 5001:5000 --gpus all my-model\n\n# If you're on an M1 Mac:\ndocker run -d -p 5001:5000 --platform=linux/amd64 my-model\n</code></pre> <p>The server is now running locally on port 5001.</p> <p>To view the OpenAPI schema,  open localhost:5001/openapi.json  in your browser  or use cURL to make a request:</p> <pre><code>curl http://localhost:5001/openapi.json\n</code></pre> <p>To stop the server, run:</p> <pre><code>docker kill my-model\n</code></pre> <p>To run a prediction on the model,  call the <code>/predictions</code> endpoint,  passing input in the format expected by your model:</p> <pre><code>curl http://localhost:5001/predictions -X POST \\\n    --header \"Content-Type: application/json\" \\\n    --data '{\"input\": {\"image\": \"https://.../input.jpg\"}}'\n</code></pre> <p>For more details about the HTTP API,  see the HTTP API reference documentation.</p>"},{"location":"deploy/#options","title":"Options","text":"<p>Cog Docker images have <code>python -m cog.server.http</code> set as the default command, which gets overridden if you pass a command to <code>docker run</code>. When you use command-line options, you need to pass in the full command before the options.</p>"},{"location":"deploy/#-threads","title":"<code>--threads</code>","text":"<p>This controls how many threads are used by Cog, which determines how many requests Cog serves in parallel. If your model uses a CPU, this is the number of CPUs on your machine. If your model uses a GPU, this is 1, because typically a GPU can only be used by one process.</p> <p>You might need to adjust this if you want to control how much memory your model uses, or other similar constraints. To do this, you can use the <code>--threads</code> option.</p> <p>For example:</p> <pre><code>docker run -d -p 5000:5000 my-model python -m cog.server.http --threads=10\n</code></pre>"},{"location":"deploy/#-host","title":"<code>--host</code>","text":"<p>By default, Cog serves to <code>0.0.0.0</code>. You can override this using the <code>--host</code> option.</p> <p>For example,  to serve Cog on an IPv6 address, run:</p> <pre><code>docker run -d -p 5000:5000 my-model python -m cog.server.http --host=\"::\"\n</code></pre>"},{"location":"environment/","title":"Environment variables","text":"<p>This guide lists the environment variables that change how Cog functions.</p>"},{"location":"environment/#build-time-variables","title":"Build-time variables","text":""},{"location":"environment/#cog_sdk_wheel","title":"<code>COG_SDK_WHEEL</code>","text":"<p>Controls which cog Python SDK wheel is installed in the Docker image during <code>cog build</code>. Takes precedence over <code>build.sdk_version</code> in <code>cog.yaml</code>.</p> <p>Supported values:</p> Value Description <code>pypi</code> Install latest version from PyPI <code>pypi:0.12.0</code> Install specific version from PyPI <code>dist</code> Use wheel from <code>dist/</code> directory (requires git repo) <code>https://...</code> Install from URL <code>/path/to/wheel.whl</code> Install from local file path <p>Default behavior:</p> <ul> <li>Release builds: Installs latest cog from PyPI</li> <li>Development builds: Auto-detects wheel in <code>dist/</code> directory, falls back to latest PyPI</li> </ul> <p>Examples:</p> <pre><code># Use specific PyPI version\n$ COG_SDK_WHEEL=pypi:0.11.0 cog build\n\n# Use local development wheel\n$ COG_SDK_WHEEL=dist cog build\n\n# Use wheel from URL\n$ COG_SDK_WHEEL=https://example.com/cog-0.12.0-py3-none-any.whl cog build\n</code></pre> <p>The <code>dist</code> option searches for wheels in: 1. <code>./dist/</code> (current directory) 2. <code>$REPO_ROOT/dist/</code> (if REPO_ROOT is set) 3. <code>&lt;git-repo-root&gt;/dist/</code> (via <code>git rev-parse</code>, useful when running from subdirectories)</p>"},{"location":"environment/#coglet_wheel","title":"<code>COGLET_WHEEL</code>","text":"<p>Controls which coglet wheel is installed in the Docker image. Coglet is the Rust-based prediction server.</p> <p>Supported values: Same as <code>COG_SDK_WHEEL</code></p> <p>Default behavior: For development builds, auto-detects a wheel in <code>dist/</code>. For release builds, installs the latest version from PyPI. Can be overridden with an explicit value.</p> <p>Examples:</p> <pre><code># Use local development wheel\n$ COGLET_WHEEL=dist cog build\n\n# Use specific version from PyPI\n$ COGLET_WHEEL=pypi:0.1.0 cog build\n</code></pre>"},{"location":"environment/#runtime-variables","title":"Runtime variables","text":""},{"location":"environment/#cog_no_update_check","title":"<code>COG_NO_UPDATE_CHECK</code>","text":"<p>By default, Cog automatically checks for updates  and notifies you if there is a new version available.</p> <p>To disable this behavior,  set the <code>COG_NO_UPDATE_CHECK</code> environment variable to any value.</p> <pre><code>$ COG_NO_UPDATE_CHECK=1 cog build  # runs without automatic update check\n</code></pre>"},{"location":"getting-started-own-model/","title":"Getting started with your own model","text":"<p>This guide will show you how to put your own machine learning model in a Docker image using Cog. If you haven't got a model to try out, you'll want to follow the main getting started guide.</p>"},{"location":"getting-started-own-model/#prerequisites","title":"Prerequisites","text":"<ul> <li>macOS or Linux. Cog works on macOS and Linux, but does not currently support Windows.</li> <li>Docker. Cog uses Docker to create a container for your model. You'll need to install Docker before you can run Cog.</li> </ul>"},{"location":"getting-started-own-model/#initialization","title":"Initialization","text":"<p>First, install Cog if you haven't already:</p> <pre><code>sudo curl -o /usr/local/bin/cog -L https://github.com/replicate/cog/releases/latest/download/cog_`uname -s`_`uname -m`\nsudo chmod +x /usr/local/bin/cog\n</code></pre> <p>To configure your project for use with Cog, you'll need to add two files:</p> <ul> <li><code>cog.yaml</code> defines system requirements, Python package dependencies, etc</li> <li><code>predict.py</code> describes the prediction interface for your model</li> </ul> <p>Use the <code>cog init</code> command to generate these files in your project:</p> <pre><code>$ cd path/to/your/model\n$ cog init\n</code></pre>"},{"location":"getting-started-own-model/#define-the-docker-environment","title":"Define the Docker environment","text":"<p>The <code>cog.yaml</code> file defines all the different things that need to be installed for your model to run. You can think of it as a simple way of defining a Docker image.</p> <p>For example:</p> <pre><code>build:\n  python_version: \"3.12\"\n  python_requirements: requirements.txt\n</code></pre> <p>With a <code>requirements.txt</code> containing your dependencies:</p> <pre><code>torch==2.6.0\n</code></pre> <p>This will generate a Docker image with Python 3.12 and PyTorch 2 installed, for both CPU and GPU, with the correct version of CUDA, and various other sensible best-practices.</p> <p>To run a command inside this environment, prefix it with <code>cog run</code>:</p> <pre><code>$ cog run python\n\u2713 Building Docker image from cog.yaml... Successfully built 8f54020c8981\nRunning 'python' in Docker with the current directory mounted as a volume...\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nPython 3.12.0 (main, Oct  2 2023, 15:45:55)\n[GCC 12.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt;\n</code></pre> <p>This is handy for ensuring a consistent environment for development or training.</p> <p>With <code>cog.yaml</code>, you can also install system packages and other things. Take a look at the full reference to see what else you can do.</p>"},{"location":"getting-started-own-model/#define-how-to-run-predictions","title":"Define how to run predictions","text":"<p>The next step is to update <code>predict.py</code> to define the interface for running predictions on your model. The <code>predict.py</code> generated by <code>cog init</code> looks something like this:</p> <pre><code>from cog import BasePredictor, Path, Input\nimport torch\n\nclass Predictor(BasePredictor):\n    def setup(self):\n        \"\"\"Load the model into memory to make running multiple predictions efficient\"\"\"\n        self.net = torch.load(\"weights.pth\")\n\n    def predict(self,\n            image: Path = Input(description=\"Image to enlarge\"),\n            scale: float = Input(description=\"Factor to scale image by\", default=1.5)\n    ) -&gt; Path:\n        \"\"\"Run a single prediction on the model\"\"\"\n        # ... pre-processing ...\n        output = self.net(input)\n        # ... post-processing ...\n        return output\n</code></pre> <p>Edit your <code>predict.py</code> file and fill in the functions with your own model's setup and prediction code. You might need to import parts of your model from another file.</p> <p>You also need to define the inputs to your model as arguments to the <code>predict()</code> function, as demonstrated above. For each argument, you need to annotate with a type. The supported types are:</p> <ul> <li><code>str</code>: a string</li> <li><code>int</code>: an integer</li> <li><code>float</code>: a floating point number</li> <li><code>bool</code>: a boolean</li> <li><code>cog.File</code>: a file-like object representing a file</li> <li><code>cog.Path</code>: a path to a file on disk</li> </ul> <p>You can provide more information about the input with the <code>Input()</code> function, as shown above. It takes these basic arguments:</p> <ul> <li><code>description</code>: A description of what to pass to this input for users of the model</li> <li><code>default</code>: A default value to set the input to. If this argument is not passed, the input is required. If it is explicitly set to <code>None</code>, the input is optional.</li> <li><code>ge</code>: For <code>int</code> or <code>float</code> types, the value should be greater than or equal to this number.</li> <li><code>le</code>: For <code>int</code> or <code>float</code> types, the value should be less than or equal to this number.</li> <li><code>choices</code>: For <code>str</code> or <code>int</code> types, a list of possible values for this input.</li> </ul> <p>There are some more advanced options you can pass, too. For more details, take a look at the prediction interface documentation.</p> <p>Next, add the line <code>predict: \"predict.py:Predictor\"</code> to your <code>cog.yaml</code>, so it looks something like this:</p> <pre><code>build:\n  python_version: \"3.12\"\n  python_requirements: requirements.txt\npredict: \"predict.py:Predictor\"\n</code></pre> <p>That's it! To test this works, try running a prediction on the model:</p> <pre><code>$ cog predict -i image=@input.jpg\n\u2713 Building Docker image from cog.yaml... Successfully built 664ef88bc1f4\n\u2713 Model running in Docker image 664ef88bc1f4\n\nWritten output to output.png\n</code></pre> <p>To pass more inputs to the model, you can add more <code>-i</code> options:</p> <pre><code>$ cog predict -i image=@image.jpg -i scale=2.0\n</code></pre> <p>In this case it is just a number, not a file, so you don't need the <code>@</code> prefix.</p>"},{"location":"getting-started-own-model/#using-gpus","title":"Using GPUs","text":"<p>To use GPUs with Cog, add the <code>gpu: true</code> option to the <code>build</code> section of your <code>cog.yaml</code>:</p> <pre><code>build:\n  gpu: true\n  ...\n</code></pre> <p>Cog will use the nvidia-docker base image and automatically figure out what versions of CUDA and cuDNN to use based on the version of Python, PyTorch, and Tensorflow that you are using.</p> <p>For more details, see the <code>gpu</code> section of the <code>cog.yaml</code> reference.</p>"},{"location":"getting-started-own-model/#next-steps","title":"Next steps","text":"<p>Next, you might want to take a look at:</p> <ul> <li>A guide explaining how to deploy a model.</li> <li>The reference for <code>cog.yaml</code></li> <li>The reference for the Python library</li> </ul>"},{"location":"getting-started/","title":"Getting started","text":"<p>This guide will walk you through what you can do with Cog by using an example model.</p> <p>[!TIP] Using a language model to help you write the code for your new Cog model?</p> <p>Feed it https://cog.run/llms.txt, which has all of Cog's documentation bundled into a single file. To learn more about this format, check out llmstxt.org.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>macOS or Linux. Cog works on macOS and Linux, but does not currently support Windows.</li> <li>Docker. Cog uses Docker to create a container for your model. You'll need to install Docker before you can run Cog.</li> </ul>"},{"location":"getting-started/#install-cog","title":"Install Cog","text":"<p>macOS (recommended):</p> <pre><code>brew install replicate/tap/cog\n</code></pre> <p>Linux or macOS (manual):</p> <pre><code>sudo curl -o /usr/local/bin/cog -L https://github.com/replicate/cog/releases/latest/download/cog_`uname -s`_`uname -m`\nsudo chmod +x /usr/local/bin/cog\nsudo xattr -d com.apple.quarantine /usr/local/bin/cog 2&gt;/dev/null || true\n</code></pre> <p>[!NOTE] macOS: \"cannot be opened because the developer cannot be verified\"</p> <p>If you downloaded the binary manually (via <code>curl</code> or a browser) and see this Gatekeeper warning, run:</p> <pre><code>sudo xattr -d com.apple.quarantine /usr/local/bin/cog\n</code></pre> <p>Installing via <code>brew install replicate/tap/cog</code> handles this automatically.</p>"},{"location":"getting-started/#create-a-project","title":"Create a project","text":"<p>Let's make a directory to work in:</p> <pre><code>mkdir cog-quickstart\ncd cog-quickstart\n</code></pre>"},{"location":"getting-started/#run-commands","title":"Run commands","text":"<p>The simplest thing you can do with Cog is run a command inside a Docker environment.</p> <p>The first thing you need to do is create a file called <code>cog.yaml</code>:</p> <pre><code>build:\n  python_version: \"3.12\"\n</code></pre> <p>Then, you can run any command inside this environment. For example, enter</p> <pre><code>cog run python\n</code></pre> <p>and you'll get an interactive Python shell:</p> <pre><code>\u2713 Building Docker image from cog.yaml... Successfully built 8f54020c8981\nRunning 'python' in Docker with the current directory mounted as a volume...\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nPython 3.12.0 (main, Oct  2 2023, 15:45:55)\n[GCC 12.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt;\n</code></pre> <p>(Hit Ctrl-D to exit the Python shell.)</p> <p>Inside this Docker environment you can do anything \u2013\u00a0run a Jupyter notebook, your training script, your evaluation script, and so on.</p>"},{"location":"getting-started/#run-predictions-on-a-model","title":"Run predictions on a model","text":"<p>Let's pretend we've trained a model. With Cog, we can define how to run predictions on it in a standard way, so other people can easily run predictions on it without having to hunt around for a prediction script.</p> <p>We need to write some code to describe how predictions are run on the model.</p> <p>Save this to <code>predict.py</code>:</p> <pre><code>import os\nos.environ[\"TORCH_HOME\"] = \".\"\n\nimport torch\nfrom cog import BasePredictor, Input, Path\nfrom PIL import Image\nfrom torchvision import models\n\nWEIGHTS = models.ResNet50_Weights.IMAGENET1K_V1\n\n\nclass Predictor(BasePredictor):\n    def setup(self):\n        \"\"\"Load the model into memory to make running multiple predictions efficient\"\"\"\n        self.device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n        self.model = models.resnet50(weights=WEIGHTS).to(self.device)\n        self.model.eval()\n\n    def predict(self, image: Path = Input(description=\"Image to classify\")) -&gt; dict:\n        \"\"\"Run a single prediction on the model\"\"\"\n        img = Image.open(image).convert(\"RGB\")\n        preds = self.model(WEIGHTS.transforms()(img).unsqueeze(0).to(self.device))\n        top3 = preds[0].softmax(0).topk(3)\n        categories = WEIGHTS.meta[\"categories\"]\n        return {categories[i]: p.detach().item() for p, i in zip(*top3)}\n</code></pre> <p>We also need to point Cog at this, and tell it what Python dependencies to install.</p> <p>Save this to <code>requirements.txt</code>:</p> <pre><code>pillow==11.1.0\ntorch==2.6.0\ntorchvision==0.21.0\n</code></pre> <p>Then update <code>cog.yaml</code> to look like this:</p> <pre><code>build:\n  python_version: \"3.12\"\n  python_requirements: requirements.txt\npredict: \"predict.py:Predictor\"\n</code></pre> <p>[!TIP] If you have a machine with an NVIDIA GPU attached, add <code>gpu: true</code> to the <code>build</code> section of your <code>cog.yaml</code> to enable GPU acceleration.</p> <p>Let's grab an image to test the model with:</p> <pre><code>IMAGE_URL=https://gist.githubusercontent.com/bfirsh/3c2115692682ae260932a67d93fd94a8/raw/56b19f53f7643bb6c0b822c410c366c3a6244de2/mystery.jpg\ncurl $IMAGE_URL &gt; input.jpg\n</code></pre> <p>Now, let's run the model using Cog:</p> <pre><code>cog predict -i image=@input.jpg\n</code></pre> <p>If you see the following output</p> <pre><code>{\n  \"tiger_cat\": 0.4874822497367859,\n  \"tabby\": 0.23169134557247162,\n  \"Egyptian_cat\": 0.09728282690048218\n}\n</code></pre> <p>then it worked!</p> <p>Note: The first time you run <code>cog predict</code>, the build process will be triggered to generate a Docker container that can run your model. The next time you run <code>cog predict</code> the pre-built container will be used.</p>"},{"location":"getting-started/#build-an-image","title":"Build an image","text":"<p>We can bake your model's code, the trained weights, and the Docker environment into a Docker image. This image serves predictions with an HTTP server, and can be deployed to anywhere that Docker runs to serve real-time predictions.</p> <pre><code>cog build -t resnet\n# Building Docker image...\n# Built resnet:latest\n</code></pre> <p>You can run this image with <code>cog predict</code> by passing the filename as an argument:</p> <pre><code>cog predict resnet -i image=@input.jpg\n</code></pre> <p>Or, you can run it with Docker directly, and it'll serve an HTTP server:</p> <pre><code>docker run -d --rm -p 5000:5000 resnet\n</code></pre> <p>We can send inputs directly with <code>curl</code>:</p> <pre><code>curl http://localhost:5000/predictions -X POST \\\n    -H 'Content-Type: application/json' \\\n    -d '{\"input\": {\"image\": \"https://gist.githubusercontent.com/bfirsh/3c2115692682ae260932a67d93fd94a8/raw/56b19f53f7643bb6c0b822c410c366c3a6244de2/mystery.jpg\"}}'\n</code></pre> <p>As a shorthand, you can add the Docker image's name as an extra line in <code>cog.yaml</code>:</p> <pre><code>image: \"r8.im/replicate/resnet\"\n</code></pre> <p>Once you've done this, you can use <code>cog push</code> to build and push the image to a Docker registry:</p> <pre><code>cog push\n# Building r8.im/replicate/resnet...\n# Pushing r8.im/replicate/resnet...\n# Pushed!\n</code></pre> <p>The Docker image is now accessible to anyone or any system that has access to this Docker registry.</p>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<p>Those are the basics! Next, you might want to take a look at:</p> <ul> <li>A guide to help you set up your own model on Cog.</li> <li>A guide explaining how to deploy a model.</li> <li>Reference for <code>cog.yaml</code></li> <li>Reference for the Python library</li> </ul>"},{"location":"http/","title":"HTTP API","text":"<p>[!TIP] For information about how to run the HTTP server,  see our documentation on deploying models.</p> <p>When you run a Docker image built by Cog,  it serves an HTTP API for making predictions.</p> <p>The server supports both synchronous and asynchronous prediction creation:</p> <ul> <li>Synchronous:    The server waits until the prediction is completed   and responds with the result.</li> <li>Asynchronous:    The server immediately returns a response    and processes the prediction in the background. </li> </ul> <p>The client can create a prediction asynchronously by setting the <code>Prefer: respond-async</code> header in their request. When provided, the server responds immediately after starting the prediction  with <code>202 Accepted</code> status and a prediction object in status <code>processing</code>.</p> <p>[!NOTE] The only supported way to receive updates on the status of predictions started asynchronously is using webhooks.  Polling for prediction status is not currently supported.</p> <p>You can also use certain server endpoints to create predictions idempotently, such that if a client calls this endpoint more than once with the same ID  (for example, due to a network interruption)  while the prediction is still running,  no new prediction is created.  Instead, the client receives a <code>202 Accepted</code> response with the initial state of the prediction.</p> <p>Here's a summary of the prediction creation endpoints:</p> Endpoint Header Behavior <code>POST /predictions</code> - Synchronous, non-idempotent <code>POST /predictions</code> <code>Prefer: respond-async</code> Asynchronous, non-idempotent <code>PUT /predictions/&lt;prediction_id&gt;</code> - Synchronous, idempotent <code>PUT /predictions/&lt;prediction_id&gt;</code> <code>Prefer: respond-async</code> Asynchronous, idempotent <p>Choose the endpoint that best fits your needs:</p> <ul> <li>Use synchronous endpoints when you want to wait for the prediction result.</li> <li>Use asynchronous endpoints when you want to start a prediction    and receive updates via webhooks.</li> <li>Use idempotent endpoints when you need to safely retry requests    without creating duplicate predictions.</li> </ul>"},{"location":"http/#webhooks","title":"Webhooks","text":"<p>You can provide a <code>webhook</code> parameter in the client request body when creating a prediction.</p> <pre><code>POST /predictions HTTP/1.1\nContent-Type: application/json; charset=utf-8\nPrefer: respond-async\n\n{\n    \"input\": {\"prompt\": \"A picture of an onion with sunglasses\"},\n    \"webhook\": \"https://example.com/webhook/prediction\"\n}\n</code></pre> <p>The server makes requests to the provided URL with the current state of the prediction object in the request body at the following times.</p> <ul> <li><code>start</code>:    Once, when the prediction starts   (<code>status</code> is <code>starting</code>).</li> <li><code>output</code>:    Each time a predict function generates an output    (either once using <code>return</code> or multiple times using <code>yield</code>)</li> <li><code>logs</code>:    Each time the predict function writes to <code>stdout</code></li> <li><code>completed</code>:    Once, when the prediction reaches a terminal state    (<code>status</code> is <code>succeeded</code>, <code>canceled</code>, or <code>failed</code>)</li> </ul> <p>Webhook requests for <code>start</code> and <code>completed</code> event types  are sent immediately. Webhook requests for <code>output</code> and <code>logs</code> event types  are sent at most once every 500ms. This interval is not configurable.</p> <p>By default, the server sends requests for all event types.  Clients can specify which events trigger webhook requests  with the <code>webhook_events_filter</code> parameter in the prediction request body.  For example, the following request specifies that webhooks are sent by the server only at the start and end of the prediction:</p> <pre><code>POST /predictions HTTP/1.1\nContent-Type: application/json; charset=utf-8\nPrefer: respond-async\n\n{\n    \"input\": {\"prompt\": \"A picture of an onion with sunglasses\"},\n    \"webhook\": \"https://example.com/webhook/prediction\",\n    \"webhook_events_filter\": [\"start\", \"completed\"]\n}\n</code></pre>"},{"location":"http/#generating-unique-prediction-ids","title":"Generating unique prediction IDs","text":"<p>Endpoints for creating and canceling a prediction idempotently accept a <code>prediction_id</code> parameter in their path. The server can run only one prediction at a time. The client must ensure that the running prediction is complete before creating a new one with a different ID.</p> <p>Clients are responsible for providing unique prediction IDs. We recommend generating a UUIDv4 or UUIDv7, base32-encoding that value, and removing padding characters (<code>==</code>). This produces a random identifier that is 26 ASCII characters long.</p> <pre><code>&gt;&gt; from uuid import uuid4\n&gt;&gt; from base64 import b32encode\n&gt;&gt; b32encode(uuid4().bytes).decode('utf-8').lower().rstrip('=')\n'wjx3whax6rf4vphkegkhcvpv6a'\n</code></pre>"},{"location":"http/#file-uploads","title":"File uploads","text":"<p>A model's <code>predict</code> function can produce file output by yielding or returning a <code>cog.Path</code> or <code>cog.File</code> value.</p> <p>By default, files are returned as a base64-encoded  data URL.</p> <pre><code>POST /predictions HTTP/1.1\nContent-Type: application/json; charset=utf-8\n\n{\n    \"input\": {\"prompt\": \"A picture of an onion with sunglasses\"},\n}\n</code></pre> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"status\": \"succeeded\",\n    \"output\": \"data:image/png;base64,...\"\n}\n</code></pre> <p>When creating a prediction synchronously, the client can configure a base URL to upload output files to instead by setting the <code>output_file_prefix</code> parameter in the request body:</p> <pre><code>POST /predictions HTTP/1.1\nContent-Type: application/json; charset=utf-8\n\n{\n    \"input\": {\"prompt\": \"A picture of an onion with sunglasses\"},\n    \"output_file_prefix\": \"https://example.com/upload\",\n}\n</code></pre> <p>When the model produces a file output, the server sends the following request to upload the file to the configured URL:</p> <pre><code>PUT /upload HTTP/1.1\nHost: example.com\nContent-Type: multipart/form-data\n\n--boundary\nContent-Disposition: form-data; name=\"file\"; filename=\"image.png\"\nContent-Type: image/png\n\n&lt;binary data&gt;\n--boundary--\n</code></pre> <p>If the upload succeeds, the server responds with output:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"status\": \"succeeded\",\n    \"output\": \"http://example.com/upload/image.png\"\n}\n</code></pre> <p>If the upload fails, the server responds with an error.</p> <p>[!IMPORTANT] File uploads for predictions created asynchronously  require <code>--upload-url</code> to be specified when starting the HTTP server.</p> <p></p>"},{"location":"http/#endpoints","title":"Endpoints","text":""},{"location":"http/#get-health-check","title":"<code>GET /health-check</code>","text":"<p>Returns the current health status of the model container. This endpoint always responds with <code>200 OK</code> \u2014 check the <code>status</code> field in the response body to determine readiness.</p> <p>The response body is a JSON object with the following fields:</p> <ul> <li><code>status</code>: One of the following values:</li> <li><code>STARTING</code>: The model's <code>setup()</code> method is still running.</li> <li><code>READY</code>: The model is ready to accept predictions.</li> <li><code>BUSY</code>: The model is ready but all prediction slots are in use.</li> <li><code>SETUP_FAILED</code>: The model's <code>setup()</code> method raised an exception.</li> <li><code>DEFUNCT</code>: The model encountered an unrecoverable error.</li> <li><code>UNHEALTHY</code>: The model is ready     but a user-defined <code>healthcheck()</code> method returned <code>False</code>.</li> <li><code>setup</code>: Setup phase details (included once setup has started):</li> <li><code>started_at</code>: ISO 8601 timestamp of when setup began.</li> <li><code>completed_at</code>: ISO 8601 timestamp of when setup finished (if complete).</li> <li><code>status</code>: One of <code>starting</code>, <code>succeeded</code>, or <code>failed</code>.</li> <li><code>logs</code>: Output captured during setup.</li> <li><code>version</code>: Runtime version information:</li> <li><code>coglet</code>: Coglet version.</li> <li><code>cog</code>: Cog Python SDK version (if available).</li> <li><code>python</code>: Python version (if available).</li> <li><code>user_healthcheck_error</code>:   Error message from a user-defined <code>healthcheck()</code> method (if applicable).</li> </ul> <pre><code>GET /health-check HTTP/1.1\n</code></pre> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"status\": \"READY\",\n    \"setup\": {\n        \"started_at\": \"2025-01-01T00:00:00.000000+00:00\",\n        \"completed_at\": \"2025-01-01T00:00:05.000000+00:00\",\n        \"status\": \"succeeded\",\n        \"logs\": \"\"\n    },\n    \"version\": {\n        \"coglet\": \"0.17.0\",\n        \"cog\": \"0.14.0\",\n        \"python\": \"3.12.0\"\n    }\n}\n</code></pre>"},{"location":"http/#get-openapijson","title":"<code>GET /openapi.json</code>","text":"<p>The OpenAPI specification of the API,  which is derived from the input and output types specified in your model's  Predictor and Training objects.</p>"},{"location":"http/#post-predictions","title":"<code>POST /predictions</code>","text":"<p>Makes a single prediction.</p> <p>The request body is a JSON object with the following fields:</p> <ul> <li><code>input</code>:    A JSON object with the same keys as the    arguments to the <code>predict()</code> function.   Any <code>File</code> or <code>Path</code> inputs are passed as URLs.</li> </ul> <p>The response body is a JSON object with the following fields:</p> <ul> <li><code>status</code>: Either <code>succeeded</code> or <code>failed</code>.</li> <li><code>output</code>: The return value of the <code>predict()</code> function.</li> <li><code>error</code>: If <code>status</code> is <code>failed</code>, the error message.</li> <li><code>metrics</code>: An object containing prediction metrics.   Always includes <code>predict_time</code> (elapsed seconds).   May also include custom metrics recorded by the model   using <code>self.record_metric()</code>.</li> </ul> <pre><code>POST /predictions HTTP/1.1\nContent-Type: application/json; charset=utf-8\n\n{\n    \"input\": {\n        \"image\": \"https://example.com/image.jpg\",\n        \"text\": \"Hello world!\"\n    }\n}\n</code></pre> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"status\": \"succeeded\",\n    \"output\": \"data:image/png;base64,...\",\n    \"metrics\": {\n        \"predict_time\": 4.52\n    }\n}\n</code></pre> <p>If the client sets the <code>Prefer: respond-async</code> header in their request, the server responds immediately after starting the prediction  with <code>202 Accepted</code> status and a prediction object in status <code>processing</code>.</p> <pre><code>POST /predictions HTTP/1.1\nContent-Type: application/json; charset=utf-8\nPrefer: respond-async\n\n{\n    \"input\": {\"prompt\": \"A picture of an onion with sunglasses\"}\n}\n</code></pre> <pre><code>HTTP/1.1 202 Accepted\nContent-Type: application/json\n\n{\n    \"status\": \"starting\",\n}\n</code></pre>"},{"location":"http/#put-predictionsprediction_id","title":"<code>PUT /predictions/&lt;prediction_id&gt;</code>","text":"<p>Make a single prediction. This is the idempotent version of the <code>POST /predictions</code> endpoint.</p> <pre><code>PUT /predictions/wjx3whax6rf4vphkegkhcvpv6a HTTP/1.1\nContent-Type: application/json; charset=utf-8\n\n{\n    \"input\": {\"prompt\": \"A picture of an onion with sunglasses\"}\n}\n</code></pre> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"status\": \"succeeded\",\n    \"output\": \"data:image/png;base64,...\"\n}\n</code></pre> <p>If the client sets the <code>Prefer: respond-async</code> header in their request, the server responds immediately after starting the prediction  with <code>202 Accepted</code> status and a prediction object in status <code>processing</code>.</p> <pre><code>PUT /predictions/wjx3whax6rf4vphkegkhcvpv6a HTTP/1.1\nContent-Type: application/json; charset=utf-8\nPrefer: respond-async\n\n{\n    \"input\": {\"prompt\": \"A picture of an onion with sunglasses\"}\n}\n</code></pre> <pre><code>HTTP/1.1 202 Accepted\nContent-Type: application/json\n\n{\n    \"id\": \"wjx3whax6rf4vphkegkhcvpv6a\",\n    \"status\": \"starting\"\n}\n</code></pre>"},{"location":"http/#post-predictionsprediction_idcancel","title":"<code>POST /predictions/&lt;prediction_id&gt;/cancel</code>","text":"<p>A client can cancel an asynchronous prediction by making a <code>POST /predictions/&lt;prediction_id&gt;/cancel</code> request using the prediction <code>id</code> provided when the prediction was created.</p> <p>For example,  if the client creates a prediction by sending the request:</p> <pre><code>POST /predictions HTTP/1.1\nContent-Type: application/json; charset=utf-8\nPrefer: respond-async\n\n{\n    \"id\": \"abcd1234\",\n    \"input\": {\"prompt\": \"A picture of an onion with sunglasses\"},\n}\n</code></pre> <p>The client can cancel the prediction by sending the request:</p> <pre><code>POST /predictions/abcd1234/cancel HTTP/1.1\n</code></pre> <p>A prediction cannot be canceled if it's created synchronously, without the <code>Prefer: respond-async</code> header, or created without a provided <code>id</code>.</p> <p>If a prediction exists with the provided <code>id</code>, the server responds with status <code>200 OK</code>. Otherwise, the server responds with status <code>404 Not Found</code>.</p> <p>When a prediction is canceled, Cog raises <code>CancelationException</code> in sync predictors (or <code>asyncio.CancelledError</code> in async predictors). This exception may be caught by the model to perform necessary cleanup. The cleanup should be brief, ideally completing within a few seconds. After cleanup, the exception must be re-raised using a bare <code>raise</code> statement. Failure to re-raise the exception may result in the termination of the container.</p> <pre><code>from cog import CancelationException, Path\n\ndef predict(image: Path) -&gt; Path:\n    try:\n        return process(image)\n    except CancelationException:\n        cleanup()\n        raise  # always re-raise\n</code></pre>"},{"location":"notebooks/","title":"Notebooks","text":"<p>Cog plays nicely with Jupyter notebooks.</p>"},{"location":"notebooks/#install-the-jupyterlab-python-package","title":"Install the jupyterlab Python package","text":"<p>First, add <code>jupyterlab</code> to your <code>requirements.txt</code> file and reference it in <code>cog.yaml</code>:</p> <p><code>requirements.txt</code>: <pre><code>jupyterlab==3.3.4\n</code></pre></p> <p><code>cog.yaml</code>: <pre><code>build:\n  python_requirements: requirements.txt\n</code></pre></p>"},{"location":"notebooks/#run-a-notebook","title":"Run a notebook","text":"<p>Cog can run notebooks in the environment you've defined in <code>cog.yaml</code> with the following command:</p> <pre><code>cog run -p 8888 jupyter lab --allow-root --ip=0.0.0.0\n</code></pre>"},{"location":"notebooks/#use-notebook-code-in-your-predictor","title":"Use notebook code in your predictor","text":"<p>You can also import a notebook into your Cog Predictor file.</p> <p>First, export your notebook to a Python file:</p> <pre><code>jupyter nbconvert --to script my_notebook.ipynb # creates my_notebook.py\n</code></pre> <p>Then import the exported Python script into your <code>predict.py</code> file. Any functions or variables defined in your notebook will be available to your predictor:</p> <pre><code>from cog import BasePredictor, Input\n\nimport my_notebook\n\nclass Predictor(BasePredictor):\n    def predict(self, prompt: str = Input(description=\"string prompt\")) -&gt; str:\n      output = my_notebook.do_stuff(prompt)\n      return output\n</code></pre>"},{"location":"private-package-registry/","title":"Private package registry","text":"<p>This guide describes how to build a Docker image with Cog that fetches Python packages from a private registry during setup.</p>"},{"location":"private-package-registry/#pipconf","title":"<code>pip.conf</code>","text":"<p>In a directory outside your Cog project, create a <code>pip.conf</code> file with an <code>index-url</code> set to the registry's URL with embedded credentials.</p> <pre><code>[global]\nindex-url = https://username:password@my-private-registry.com\n</code></pre> <p>Warning Be careful not to commit secrets in Git or include them in Docker images. If your Cog project contains any sensitive files, make sure they're listed in <code>.gitignore</code> and <code>.dockerignore</code>.</p>"},{"location":"private-package-registry/#cogyaml","title":"<code>cog.yaml</code>","text":"<p>In your project's <code>cog.yaml</code> file, add a setup command to run <code>pip install</code> with a secret configuration file mounted to <code>/etc/pip.conf</code>.</p> <pre><code>build:\n  run:\n    - command: pip install\n      mounts:\n        - type: secret\n          id: pip\n          target: /etc/pip.conf\n</code></pre>"},{"location":"private-package-registry/#build","title":"Build","text":"<p>When building or pushing your model with Cog, pass the <code>--secret</code> option with an <code>id</code> matching the one specified in <code>cog.yaml</code>, along with a path to your local <code>pip.conf</code> file.</p> <pre><code>$ cog build --secret id=pip,source=/path/to/pip.conf\n</code></pre> <p>Using a secret mount allows the private registry credentials to be securely passed to the <code>pip install</code> setup command, without baking them into the Docker image.</p> <p>Warning If you run <code>cog build</code> or <code>cog push</code> and then change the contents of a secret source file, the cached version of the file will be used on subsequent builds, ignoring any changes you made. To update the contents of the target secret file, either change the <code>id</code> value in <code>cog.yaml</code> and the <code>--secret</code> option, or pass the <code>--no-cache</code> option to bypass the cache entirely.</p>"},{"location":"python/","title":"Prediction interface reference","text":"<p>This document defines the API of the <code>cog</code> Python module, which is used to define the interface for running predictions on your model.</p> <p>[!TIP] Run <code>cog init</code> to generate an annotated <code>predict.py</code> file that can be used as a starting point for setting up your model.</p> <p>[!TIP] Using a language model to help you write the code for your new Cog model?</p> <p>Feed it https://cog.run/llms.txt, which has all of Cog's documentation bundled into a single file. To learn more about this format, check out llmstxt.org.</p>"},{"location":"python/#contents","title":"Contents","text":"<ul> <li>Contents</li> <li><code>BasePredictor</code></li> <li><code>Predictor.setup()</code></li> <li><code>Predictor.predict(**kwargs)</code></li> <li><code>async</code> predictors and concurrency</li> <li><code>Input(**kwargs)</code></li> <li>Deprecating inputs</li> <li>Output</li> <li>Returning an object</li> <li>Returning a list</li> <li>Optional properties</li> <li>Streaming output</li> <li>Metrics</li> <li>Recording metrics</li> <li>Accumulation modes</li> <li>Dot-path keys</li> <li>Type safety</li> <li>Cancellation</li> <li><code>CancelationException</code></li> <li>Input and output types</li> <li><code>File()</code></li> <li><code>Path()</code></li> <li><code>Secret</code></li> <li><code>Optional</code></li> <li><code>List</code></li> </ul>"},{"location":"python/#basepredictor","title":"<code>BasePredictor</code>","text":"<p>You define how Cog runs predictions on your model by defining a class that inherits from <code>BasePredictor</code>. It looks something like this:</p> <pre><code>from cog import BasePredictor, Path, Input\nimport torch\n\nclass Predictor(BasePredictor):\n    def setup(self):\n        \"\"\"Load the model into memory to make running multiple predictions efficient\"\"\"\n        self.model = torch.load(\"weights.pth\")\n\n    def predict(self,\n            image: Path = Input(description=\"Image to enlarge\"),\n            scale: float = Input(description=\"Factor to scale image by\", default=1.5)\n    ) -&gt; Path:\n        \"\"\"Run a single prediction on the model\"\"\"\n        # ... pre-processing ...\n        output = self.model(image)\n        # ... post-processing ...\n        return output\n</code></pre> <p>Your Predictor class should define two methods: <code>setup()</code> and <code>predict()</code>.</p>"},{"location":"python/#predictorsetup","title":"<code>Predictor.setup()</code>","text":"<p>Prepare the model so multiple predictions run efficiently.</p> <p>Use this optional method to include expensive one-off operations like loading trained models, instantiating data transformations, etc.</p> <p>Many models use this method to download their weights (e.g. using <code>pget</code>). This has some advantages:</p> <ul> <li>Smaller image sizes</li> <li>Faster build times</li> <li>Faster pushes and inference on Replicate</li> </ul> <p>However, this may also significantly increase your <code>setup()</code> time.</p> <p>As an alternative, some choose to store their weights directly in the image. You can simply leave your weights in the directory alongside your <code>cog.yaml</code> and ensure they are not excluded in your <code>.dockerignore</code> file.</p> <p>While this will increase your image size and build time, it offers other advantages:</p> <ul> <li>Faster <code>setup()</code> time</li> <li>Ensures idempotency and reduces your model's reliance on external systems</li> <li>Preserves reproducibility as your model will be self-contained in the image</li> </ul> <p>When using this method, you should use the <code>--separate-weights</code> flag on <code>cog build</code> to store weights in a separate layer.</p>"},{"location":"python/#predictorpredictkwargs","title":"<code>Predictor.predict(**kwargs)</code>","text":"<p>Run a single prediction.</p> <p>This required method is where you call the model that was loaded during <code>setup()</code>, but you may also want to add pre- and post-processing code here.</p> <p>The <code>predict()</code> method takes an arbitrary list of named arguments, where each argument name must correspond to an <code>Input()</code> annotation.</p> <p><code>predict()</code> can return strings, numbers, <code>cog.Path</code> objects representing files on disk, or lists or dicts of those types. You can also define a custom <code>Output()</code> for more complex return types.</p>"},{"location":"python/#async-predictors-and-concurrency","title":"<code>async</code> predictors and concurrency","text":"<p>Added in cog 0.14.0.</p> <p>You may specify your <code>predict()</code> method as <code>async def predict(...)</code>.  In addition, if you have an async <code>predict()</code> function you may also have an async <code>setup()</code> function:</p> <pre><code>class Predictor(BasePredictor):\n    async def setup(self) -&gt; None:\n        print(\"async setup is also supported...\")\n\n    async def predict(self) -&gt; str:\n        print(\"async predict\");\n        return \"hello world\";\n</code></pre> <p>Models that have an async <code>predict()</code> function can run predictions concurrently, up to the limit specified by <code>concurrency.max</code> in cog.yaml. Attempting to exceed this limit will return a 409 Conflict response.</p>"},{"location":"python/#inputkwargs","title":"<code>Input(**kwargs)</code>","text":"<p>Use cog's <code>Input()</code> function to define each of the parameters in your <code>predict()</code> method:</p> <pre><code>class Predictor(BasePredictor):\n    def predict(self,\n            image: Path = Input(description=\"Image to enlarge\"),\n            scale: float = Input(description=\"Factor to scale image by\", default=1.5, ge=1.0, le=10.0)\n    ) -&gt; Path:\n</code></pre> <p>The <code>Input()</code> function takes these keyword arguments:</p> <ul> <li><code>description</code>: A description of what to pass to this input for users of the model.</li> <li><code>default</code>: A default value to set the input to. If this argument is not passed, the input is required. If it is explicitly set to <code>None</code>, the input is optional.</li> <li><code>ge</code>: For <code>int</code> or <code>float</code> types, the value must be greater than or equal to this number.</li> <li><code>le</code>: For <code>int</code> or <code>float</code> types, the value must be less than or equal to this number.</li> <li><code>min_length</code>: For <code>str</code> types, the minimum length of the string.</li> <li><code>max_length</code>: For <code>str</code> types, the maximum length of the string.</li> <li><code>regex</code>: For <code>str</code> types, the string must match this regular expression.</li> <li><code>choices</code>: For <code>str</code> or <code>int</code> types, a list of possible values for this input.</li> <li><code>deprecated</code>: (optional) If set to <code>True</code>, marks this input as deprecated. Deprecated inputs will still be accepted, but tools and UIs may warn users that the input is deprecated and may be removed in the future. See Deprecating inputs.</li> </ul> <p>Each parameter of the <code>predict()</code> method must be annotated with a type like <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, etc. See Input and output types for the full list of supported types.</p> <p>Using the <code>Input</code> function provides better documentation and validation constraints to the users of your model, but it is not strictly required. You can also specify default values for your parameters using plain Python, or omit default assignment entirely:</p> <pre><code>class Predictor(BasePredictor):\n    def predict(self,\n        prompt: str = \"default prompt\", # this is valid\n        iterations: int                 # also valid\n    ) -&gt; str:\n        # ...\n</code></pre>"},{"location":"python/#deprecating-inputs","title":"Deprecating inputs","text":"<p>You can mark an input as deprecated by passing <code>deprecated=True</code> to the <code>Input()</code> function. Deprecated inputs will still be accepted, but tools and UIs may warn users that the input is deprecated and may be removed in the future.</p> <p>This is useful when you want to phase out an input without breaking existing clients immediately:</p> <pre><code>from cog import BasePredictor, Input\n\nclass Predictor(BasePredictor):\n    def predict(self,\n        text: str = Input(description=\"Some deprecated text\", deprecated=True),\n        prompt: str = Input(description=\"Prompt for the model\")\n    ) -&gt; str:\n        # ...\n        return prompt\n</code></pre>"},{"location":"python/#output","title":"Output","text":"<p>Cog predictors can return a simple data type like a string, number, float, or boolean. Use Python's <code>-&gt; &lt;type&gt;</code> syntax to annotate the return type.</p> <p>Here's an example of a predictor that returns a string:</p> <pre><code>from cog import BasePredictor\n\nclass Predictor(BasePredictor):\n    def predict(self) -&gt; str:\n        return \"hello\"\n</code></pre>"},{"location":"python/#returning-an-object","title":"Returning an object","text":"<p>To return a complex object with multiple values, define an <code>Output</code> object with multiple fields to return from your <code>predict()</code> method:</p> <pre><code>from cog import BasePredictor, BaseModel, File\n\nclass Output(BaseModel):\n    file: File\n    text: str\n\nclass Predictor(BasePredictor):\n    def predict(self) -&gt; Output:\n        return Output(text=\"hello\", file=io.StringIO(\"hello\"))\n</code></pre> <p>Each of the output object's properties must be one of the supported output types. For the full list, see Input and output types. Also, make sure to name the output class as <code>Output</code> and nothing else.</p>"},{"location":"python/#returning-a-list","title":"Returning a list","text":"<p>The <code>predict()</code> method can return a list of any of the supported output types. Here's an example that outputs multiple files:</p> <pre><code>from cog import BasePredictor, Path\n\nclass Predictor(BasePredictor):\n    def predict(self) -&gt; list[Path]:\n        predictions = [\"foo\", \"bar\", \"baz\"]\n        output = []\n        for i, prediction in enumerate(predictions):\n            out_path = Path(f\"/tmp/out-{i}.txt\")\n            with out_path.open(\"w\") as f:\n                f.write(prediction)\n            output.append(out_path)\n        return output\n</code></pre> <p>Files are named in the format <code>output.&lt;index&gt;.&lt;extension&gt;</code>, e.g. <code>output.0.txt</code>, <code>output.1.txt</code>, and <code>output.2.txt</code> from the example above.</p>"},{"location":"python/#optional-properties","title":"Optional properties","text":"<p>To conditionally omit properties from the Output object, define them using <code>typing.Optional</code>:</p> <pre><code>from cog import BaseModel, BasePredictor, Path\nfrom typing import Optional\n\nclass Output(BaseModel):\n    score: Optional[float]\n    file: Optional[Path]\n\nclass Predictor(BasePredictor):\n    def predict(self) -&gt; Output:\n        if condition:\n            return Output(score=1.5)\n        else:\n            return Output(file=io.StringIO(\"hello\"))\n</code></pre>"},{"location":"python/#streaming-output","title":"Streaming output","text":"<p>Cog models can stream output as the <code>predict()</code> method is running. For example, a language model can output tokens as they're being generated and an image generation model can output images as they are being generated.</p> <p>To support streaming output in your Cog model, add <code>from typing import Iterator</code> to your predict.py file. The <code>typing</code> package is a part of Python's standard library so it doesn't need to be installed. Then add a return type annotation to the <code>predict()</code> method in the form <code>-&gt; Iterator[&lt;type&gt;]</code> where <code>&lt;type&gt;</code> can be one of <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, or <code>cog.Path</code>.</p> <pre><code>from cog import BasePredictor, Path\nfrom typing import Iterator\n\nclass Predictor(BasePredictor):\n    def predict(self) -&gt; Iterator[Path]:\n        done = False\n        while not done:\n            output_path, done = do_stuff()\n            yield Path(output_path)\n</code></pre> <p>If you have an async <code>predict()</code> method, you must use <code>cog.AsyncIterator</code> instead:</p> <pre><code>from cog import AsyncIterator, BasePredictor, Path\n\nclass Predictor(BasePredictor):\n    async def predict(self) -&gt; AsyncIterator[Path]:\n        done = False\n        while not done:\n            output_path, done = do_stuff()\n            yield Path(output_path)\n</code></pre> <p>If you're streaming text output, you can use <code>ConcatenateIterator</code> to hint that the output should be concatenated together into a single string. This is useful on Replicate to display the output as a string instead of a list of strings.</p> <pre><code>from cog import BasePredictor, Path, ConcatenateIterator\n\nclass Predictor(BasePredictor):\n    def predict(self) -&gt; ConcatenateIterator[str]:\n        tokens = [\"The\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"the\", \"lazy\", \"dog\"]\n        for token in tokens:\n            yield token + \" \"\n</code></pre> <p>Or for async <code>predict()</code> methods, use <code>AsyncConcatenateIterator</code>:</p> <pre><code>from cog import BasePredictor, Path, AsyncConcatenateIterator\n\nclass Predictor(BasePredictor):\n    async def predict(self) -&gt; AsyncConcatenateIterator[str]:\n        tokens = [\"The\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"the\", \"lazy\", \"dog\"]\n        for token in tokens:\n            yield token + \" \"\n</code></pre>"},{"location":"python/#metrics","title":"Metrics","text":"<p>You can record custom metrics from your <code>predict()</code> function to track model-specific data like token counts, timing breakdowns, or confidence scores. Metrics are included in the prediction response alongside the output.</p>"},{"location":"python/#recording-metrics","title":"Recording metrics","text":"<p>Use <code>self.record_metric()</code> inside your <code>predict()</code> method:</p> <pre><code>from cog import BasePredictor\n\nclass Predictor(BasePredictor):\n    def predict(self, prompt: str) -&gt; str:\n        self.record_metric(\"temperature\", 0.7)\n        self.record_metric(\"token_count\", 42)\n\n        result = self.model.generate(prompt)\n        return result\n</code></pre> <p>For advanced use (dict-style access, deleting metrics), use <code>self.scope</code>:</p> <pre><code>self.scope.metrics[\"token_count\"] = 42\ndel self.scope.metrics[\"token_count\"]\n</code></pre> <p>Metrics appear in the prediction response <code>metrics</code> field:</p> <pre><code>{\n    \"status\": \"succeeded\",\n    \"output\": \"...\",\n    \"metrics\": {\n        \"temperature\": 0.7,\n        \"token_count\": 42,\n        \"predict_time\": 1.23\n    }\n}\n</code></pre> <p>The <code>predict_time</code> metric is always added automatically by the runtime. If you set <code>predict_time</code> yourself, the runtime value takes precedence.</p> <p>Supported value types are <code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code>, <code>list</code>, and <code>dict</code>. Setting a metric to <code>None</code> deletes it.</p>"},{"location":"python/#accumulation-modes","title":"Accumulation modes","text":"<p>By default, recording a metric replaces any previous value for that key. You can use accumulation modes to build up values across multiple calls:</p> <pre><code># Increment a counter (adds to the existing numeric value)\nself.record_metric(\"token_count\", 1, mode=\"incr\")\nself.record_metric(\"token_count\", 1, mode=\"incr\")\n# Result: {\"token_count\": 2}\n\n# Append to an array\nself.record_metric(\"steps\", \"preprocessing\", mode=\"append\")\nself.record_metric(\"steps\", \"inference\", mode=\"append\")\n# Result: {\"steps\": [\"preprocessing\", \"inference\"]}\n\n# Replace (default behavior)\nself.record_metric(\"status\", \"running\", mode=\"replace\")\nself.record_metric(\"status\", \"done\", mode=\"replace\")\n# Result: {\"status\": \"done\"}\n</code></pre> <p>The <code>mode</code> parameter accepts <code>\"replace\"</code> (default), <code>\"incr\"</code>, or <code>\"append\"</code>.</p>"},{"location":"python/#dot-path-keys","title":"Dot-path keys","text":"<p>Use dot-separated keys to create nested objects in the metrics output:</p> <pre><code>self.record_metric(\"timing.preprocess\", 0.12)\nself.record_metric(\"timing.inference\", 0.85)\n</code></pre> <p>This produces nested JSON:</p> <pre><code>{\n    \"metrics\": {\n        \"timing\": {\n            \"preprocess\": 0.12,\n            \"inference\": 0.85\n        },\n        \"predict_time\": 1.23\n    }\n}\n</code></pre>"},{"location":"python/#type-safety","title":"Type safety","text":"<p>Once a metric key has been assigned a value of a certain type, it cannot be changed to a different type without deleting it first. This prevents accidental type mismatches when using accumulation modes:</p> <pre><code>self.record_metric(\"count\", 1)\n\n# This would raise an error \u2014 \"count\" is an int, not a string:\n# self.record_metric(\"count\", \"oops\")\n\n# Delete first, then set with new type:\ndel self.scope.metrics[\"count\"]\nself.record_metric(\"count\", \"now a string\")\n</code></pre> <p>Outside an active prediction, <code>self.record_metric()</code> and <code>self.scope</code> are silent no-ops \u2014 no need for <code>None</code> checks.</p>"},{"location":"python/#cancellation","title":"Cancellation","text":"<p>When a prediction is canceled (via the cancel HTTP endpoint or a dropped connection), the Cog runtime interrupts the running <code>predict()</code> function. The exception raised depends on whether the predictor is sync or async:</p> Predictor type Exception raised Sync (<code>def predict</code>) <code>CancelationException</code> Async (<code>async def predict</code>) <code>asyncio.CancelledError</code>"},{"location":"python/#cancelationexception","title":"<code>CancelationException</code>","text":"<pre><code>from cog import CancelationException\n</code></pre> <p><code>CancelationException</code> is raised in sync predictors when a prediction is cancelled. It is a <code>BaseException</code> subclass \u2014 not an <code>Exception</code> subclass. This means bare <code>except Exception</code> blocks in your predict code will not accidentally catch it, matching the behavior of <code>KeyboardInterrupt</code> and <code>asyncio.CancelledError</code>.</p> <p>You do not need to handle this exception in normal predictor code \u2014 the runtime manages cancellation automatically. However, if you need to run cleanup logic when a prediction is cancelled, you can catch it explicitly:</p> <pre><code>from cog import BasePredictor, CancelationException, Path\n\nclass Predictor(BasePredictor):\n    def predict(self, image: Path) -&gt; Path:\n        try:\n            return self.process(image)\n        except CancelationException:\n            self.cleanup()\n            raise  # always re-raise\n</code></pre> <p>[!WARNING] You must re-raise <code>CancelationException</code> after cleanup. Swallowing it will prevent the runtime from marking the prediction as canceled, and may result in the termination of the container.</p> <p><code>CancelationException</code> is available as:</p> <ul> <li><code>cog.CancelationException</code> (recommended)</li> <li><code>cog.exceptions.CancelationException</code></li> </ul> <p>For async predictors, cancellation follows standard Python async conventions and raises <code>asyncio.CancelledError</code> instead.</p>"},{"location":"python/#input-and-output-types","title":"Input and output types","text":"<p>Each parameter of the <code>predict()</code> method must be annotated with a type. The method's return type must also be annotated. The supported types are:</p> <ul> <li><code>str</code>: a string</li> <li><code>int</code>: an integer</li> <li><code>float</code>: a floating point number</li> <li><code>bool</code>: a boolean</li> <li><code>cog.File</code>: a file-like object representing a file</li> <li><code>cog.Path</code>: a path to a file on disk</li> <li><code>cog.Secret</code>: a string containing sensitive information</li> </ul>"},{"location":"python/#file","title":"<code>File()</code>","text":"<p>[!WARNING] <code>cog.File</code> is deprecated and will be removed in a future version of Cog. Use <code>cog.Path</code> instead.</p> <p>The <code>cog.File</code> object is used to get files in and out of models. It represents a file handle.</p> <p>For models that return a <code>cog.File</code> object, the prediction output returned by Cog's built-in HTTP server will be a URL.</p> <pre><code>from cog import BasePredictor, File, Input, Path\nfrom PIL import Image\n\nclass Predictor(BasePredictor):\n    def predict(self, source_image: File = Input(description=\"Image to enlarge\")) -&gt; File:\n        pillow_img = Image.open(source_image)\n        upscaled_image = do_some_processing(pillow_img)\n        return File(upscaled_image)\n</code></pre>"},{"location":"python/#path","title":"<code>Path()</code>","text":"<p>The <code>cog.Path</code> object is used to get files in and out of models. It represents a path to a file on disk.</p> <p><code>cog.Path</code> is a subclass of Python's <code>pathlib.Path</code> and can be used as a drop-in replacement.</p> <p>For models that return a <code>cog.Path</code> object, the prediction output returned by Cog's built-in HTTP server will be a URL.</p> <p>This example takes an input file, resizes it, and returns the resized image:</p> <pre><code>import tempfile\nfrom cog import BasePredictor, Input, Path\n\nclass Predictor(BasePredictor):\n    def predict(self, image: Path = Input(description=\"Image to enlarge\")) -&gt; Path:\n        upscaled_image = do_some_processing(image)\n\n        # To output `cog.Path` objects the file needs to exist, so create a temporary file first.\n        # This file will automatically be deleted by Cog after it has been returned.\n        output_path = Path(tempfile.mkdtemp()) / \"upscaled.png\"\n        upscaled_image.save(output_path)\n        return Path(output_path)\n</code></pre>"},{"location":"python/#secret","title":"<code>Secret</code>","text":"<p>The <code>cog.Secret</code> type is used to signify that an input holds sensitive information, like a password or API token.</p> <p><code>cog.Secret</code> is a type that redacts its contents in string representations to prevent accidental disclosure. You can access its contents with the <code>get_secret_value()</code> method.</p> <pre><code>from cog import BasePredictor, Secret\n\n\nclass Predictor(BasePredictor):\n    def predict(self, api_token: Secret) -&gt; None:\n        # Prints '**********'\n        print(api_token)        \n\n        # Use get_secret_value method to see the secret's content.\n        print(api_token.get_secret_value())\n</code></pre> <p>A predictor's <code>Secret</code> inputs are represented in OpenAPI with the following schema:</p> <pre><code>{\n  \"type\": \"string\",\n  \"format\": \"password\",\n  \"x-cog-secret\": true,\n}\n</code></pre> <p>Models uploaded to Replicate treat secret inputs differently throughout its system. When you create a prediction on Replicate, any value passed to a <code>Secret</code> input is redacted after being sent to the model.</p> <p>[!WARNING] Passing secret values to untrusted models can result in  unintended disclosure, exfiltration, or misuse of sensitive data.</p>"},{"location":"python/#optional","title":"<code>Optional</code>","text":"<p>Optional inputs should be explicitly defined as <code>Optional[T]</code> so that type checker can warn us about error-prone <code>None</code> values.</p> <p>For example, the following code might fail if <code>prompt</code> is not specified in the inputs:</p> <pre><code>class Predictor(BasePredictor):\n    def predict(self, prompt: str=Input(description=\"prompt\", default=None)) -&gt; str:\n        return \"hello\" + prompt  # TypeError: can only concatenate str (not \"NoneType\") to str\n</code></pre> <p>We can improve it by making <code>prompt</code> an <code>Optional[str]</code>. Note that <code>default=None</code> is now redundant as <code>Optional</code> implies it.</p> <pre><code>class Predictor(BasePredictor):\n    def predict(self, prompt: Optional[str]=Input(description=\"prompt\")) -&gt; str:\n        if prompt is None:  # type check can warn us if we forget this\n            return \"hello\"\n        else:\n            return \"hello\" + prompt\n</code></pre> <p>Note that the error prone usage of <code>prompt: str=Input(default=None)</code> might throw an error in a future release of Cog.</p>"},{"location":"python/#list","title":"<code>List</code>","text":"<p>The List type is also supported in inputs. It can hold any supported type.</p> <p>Example for List[Path]: <pre><code>class Predictor(BasePredictor):\n   def predict(self, paths: list[Path]) -&gt; str:\n       output_parts = []  # Use a list to collect file contents\n       for path in paths:\n           with open(path) as f:\n             output_parts.append(f.read())\n       return \"\".join(output_parts)\n</code></pre> The corresponding cog command: <pre><code>$ echo test1 &gt; 1.txt\n$ echo test2 &gt; 2.txt\n$ cog predict -i paths=@1.txt -i paths=@2.txt\nRunning prediction...\ntest1\n\ntest2\n</code></pre> - Note the repeated inputs with the same name \"paths\" which constitute the list</p>"},{"location":"redis/","title":"Redis queue API","text":"<p>Note: The redis queue API is no longer supported and has been removed from Cog.</p>"},{"location":"training/","title":"Training interface reference","text":"<p>[!NOTE] The training API is still experimental, and is subject to change.</p> <p>Cog's training API allows you to define a fine-tuning interface for an existing Cog model, so users of the model can bring their own training data to create derivative fine-tuned models. Real-world examples of this API in use include fine-tuning SDXL with images or fine-tuning Llama 2 with structured text.</p>"},{"location":"training/#how-it-works","title":"How it works","text":"<p>If you've used Cog before, you've probably seen the Predictor class, which defines the interface for creating predictions against your model. Cog's training API works similarly: You define a Python function that describes the inputs and outputs of the training process. The inputs are things like training data, epochs, batch size, seed, etc. The output is typically a file with the fine-tuned weights.</p> <p><code>cog.yaml</code>:</p> <pre><code>build:\n  python_version: \"3.10\"\ntrain: \"train.py:train\"\n</code></pre> <p><code>train.py</code>:</p> <pre><code>from cog import BasePredictor, File\nimport io\n\ndef train(param: str) -&gt; File:\n    return io.StringIO(\"hello \" + param)\n</code></pre> <p>Then you can run it like this:</p> <pre><code>$ cog train -i param=train\n...\n\n$ cat weights\nhello train\n</code></pre> <p>You can also use classes if you want to run many model trainings and save on setup time. This works the same way as the Predictor class with the only difference being the <code>train</code> method.</p> <p><code>cog.yaml</code>:</p> <pre><code>build:\n  python_version: \"3.10\"\ntrain: \"train.py:Trainer\"\n</code></pre> <p><code>train.py</code>:</p> <pre><code>from cog import BasePredictor, File\nimport io\n\nclass Trainer:\n    def setup(self) -&gt; None:\n        self.base_model = ... # Load a big base model\n\n    def train(self, param: str) -&gt; File:\n        return self.base_model.train(param) # Train on top of a base model\n</code></pre>"},{"location":"training/#inputkwargs","title":"<code>Input(**kwargs)</code>","text":"<p>Use Cog's <code>Input()</code> function to define each of the parameters in your <code>train()</code> function:</p> <pre><code>from cog import Input, Path\n\ndef train(\n    train_data: Path = Input(description=\"HTTPS URL of a file containing training data\"),\n    learning_rate: float = Input(description=\"learning rate, for learning!\", default=1e-4, ge=0),\n    seed: int = Input(description=\"random seed to use for training\", default=None)\n) -&gt; str:\n  return \"hello, weights\"\n</code></pre> <p>The <code>Input()</code> function takes these keyword arguments:</p> <ul> <li><code>description</code>: A description of what to pass to this input for users of the model.</li> <li><code>default</code>: A default value to set the input to. If this argument is not passed, the input is required. If it is explicitly set to <code>None</code>, the input is optional.</li> <li><code>ge</code>: For <code>int</code> or <code>float</code> types, the value must be greater than or equal to this number.</li> <li><code>le</code>: For <code>int</code> or <code>float</code> types, the value must be less than or equal to this number.</li> <li><code>min_length</code>: For <code>str</code> types, the minimum length of the string.</li> <li><code>max_length</code>: For <code>str</code> types, the maximum length of the string.</li> <li><code>regex</code>: For <code>str</code> types, the string must match this regular expression.</li> <li><code>choices</code>: For <code>str</code> or <code>int</code> types, a list of possible values for this input.</li> </ul> <p>Each parameter of the <code>train()</code> function must be annotated with a type like <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, etc. See Input and output types for the full list of supported types.</p> <p>Using the <code>Input</code> function provides better documentation and validation constraints to the users of your model, but it is not strictly required. You can also specify default values for your parameters using plain Python, or omit default assignment entirely:</p> <pre><code>def predict(self,\n  training_data: str = \"foo bar\", # this is valid\n  iterations: int                 # also valid\n) -&gt; str:\n  # ...\n</code></pre>"},{"location":"training/#training-output","title":"Training Output","text":"<p>Training output is typically a binary weights file. To return a custom output object or a complex object with multiple values, define a <code>TrainingOutput</code> object with multiple fields to return from your <code>train()</code> function, and specify it as the return type for the train function using Python's <code>-&gt;</code> return type annotation:</p> <pre><code>from cog import BaseModel, Input, Path\n\nclass TrainingOutput(BaseModel):\n    weights: Path\n\ndef train(\n    train_data: Path = Input(description=\"HTTPS URL of a file containing training data\"),\n    learning_rate: float = Input(description=\"learning rate, for learning!\", default=1e-4, ge=0),\n    seed: int = Input(description=\"random seed to use for training\", default=42)\n) -&gt; TrainingOutput:\n  weights_file = generate_weights(\"...\")\n  return TrainingOutput(weights=Path(weights_file))\n</code></pre>"},{"location":"training/#testing","title":"Testing","text":"<p>If you are doing development of a Cog model like Llama or SDXL, you can test that the fine-tuned code path works before pushing by specifying a <code>COG_WEIGHTS</code> environment variable when running <code>predict</code>:</p> <pre><code>cog predict -e COG_WEIGHTS=https://replicate.delivery/pbxt/xyz/weights.tar -i prompt=\"a photo of TOK\"\n</code></pre>"},{"location":"yaml/","title":"<code>cog.yaml</code> reference","text":"<p><code>cog.yaml</code> defines how to build a Docker image and how to run predictions on your model inside that image.</p> <p>It has three keys: <code>build</code>, <code>image</code>, and <code>predict</code>. It looks a bit like this:</p> <pre><code>build:\n  python_version: \"3.11\"\n  python_requirements: requirements.txt\n  system_packages:\n    - \"ffmpeg\"\n    - \"git\"\npredict: \"predict.py:Predictor\"\n</code></pre> <p>Tip: Run <code>cog init</code> to generate an annotated <code>cog.yaml</code> file that can be used as a starting point for setting up your model.</p>"},{"location":"yaml/#build","title":"<code>build</code>","text":"<p>This stanza describes how to build the Docker image your model runs in. It contains various options within it:</p>"},{"location":"yaml/#cuda","title":"<code>cuda</code>","text":"<p>Cog automatically picks the correct version of CUDA to install, but this lets you override it for whatever reason by specifying the minor (<code>11.8</code>) or patch (<code>11.8.0</code>) version of CUDA to use.</p> <p>For example:</p> <pre><code>build:\n  cuda: \"11.8\"\n</code></pre>"},{"location":"yaml/#gpu","title":"<code>gpu</code>","text":"<p>Enable GPUs for this model. When enabled, the nvidia-docker base image will be used, and Cog will automatically figure out what versions of CUDA and cuDNN to use based on the version of Python, PyTorch, and Tensorflow that you are using.</p> <p>For example:</p> <pre><code>build:\n  gpu: true\n</code></pre> <p>When you use <code>cog run</code> or <code>cog predict</code>, Cog will automatically pass the <code>--gpus=all</code> flag to Docker. When you run a Docker image built with Cog, you'll need to pass this option to <code>docker run</code>.</p>"},{"location":"yaml/#python_requirements","title":"<code>python_requirements</code>","text":"<p>A pip requirements file specifying the Python packages to install. For example:</p> <pre><code>build:\n  python_requirements: requirements.txt\n</code></pre> <p>Your <code>cog.yaml</code> file can set either <code>python_packages</code> or <code>python_requirements</code>, but not both. Use <code>python_requirements</code> when you need to configure options like <code>--extra-index-url</code> or <code>--trusted-host</code> to fetch Python package dependencies.</p> <p>This follows the standard requirements.txt format.</p> <p>To install Git-hosted Python packages, add <code>git</code> to the <code>system_packages</code> list, then use the <code>git+https://</code> syntax to specify the package name. For example:</p> <p><code>cog.yaml</code>: <pre><code>build:\n  system_packages:\n    - \"git\"\n  python_requirements: requirements.txt\n</code></pre></p> <p><code>requirements.txt</code>: <pre><code>git+https://github.com/huggingface/transformers\n</code></pre></p> <p>You can also pin Python package installations to a specific git commit:</p> <p><code>cog.yaml</code>: <pre><code>build:\n  system_packages:\n    - \"git\"\n  python_requirements: requirements.txt\n</code></pre></p> <p><code>requirements.txt</code>: <pre><code>git+https://github.com/huggingface/transformers@2d1602a\n</code></pre></p> <p>Note that you can use a shortened prefix of the 40-character git commit SHA, but you must use at least six characters, like <code>2d1602a</code> above.</p>"},{"location":"yaml/#python_packages","title":"<code>python_packages</code>","text":"<p>DEPRECATED: This will be removed in future versions, please use python_requirements instead.</p> <p>A list of Python packages to install from the PyPi package index, in the format <code>package==version</code>. For example:</p> <pre><code>build:\n  python_packages:\n    - pillow==8.3.1\n    - tensorflow==2.5.0\n</code></pre> <p>Your <code>cog.yaml</code> file can set either <code>python_packages</code> or <code>python_requirements</code>, but not both.</p>"},{"location":"yaml/#python_version","title":"<code>python_version</code>","text":"<p>The minor (<code>3.11</code>) or patch (<code>3.11.1</code>) version of Python to use. For example:</p> <pre><code>build:\n  python_version: \"3.11.1\"\n</code></pre> <p>Cog supports Python 3.10, 3.11, 3.12, and 3.13. If you don't define a version, Cog will use the latest version of Python 3.13 or a version of Python that is compatible with the versions of PyTorch or TensorFlow you specify.</p> <p>Note that these are the versions supported in the Docker container, not your host machine. You can run any version(s) of Python you wish on your host machine.</p>"},{"location":"yaml/#run","title":"<code>run</code>","text":"<p>A list of setup commands to run in the environment\u00a0after your system packages and Python packages have been installed. If you're familiar with Docker, it's like a <code>RUN</code> instruction in your <code>Dockerfile</code>.</p> <p>For example:</p> <pre><code>build:\n  run:\n    - curl -L https://github.com/cowsay-org/cowsay/archive/refs/tags/v3.7.0.tar.gz | tar -xzf -\n    - cd cowsay-3.7.0 &amp;&amp; make install\n</code></pre> <p>Your code is not available to commands in <code>run</code>. This is so we can build your image efficiently when running locally.</p> <p>Each command in <code>run</code> can be either a string or a dictionary in the following format:</p> <pre><code>build:\n  run:\n    - command: pip install\n      mounts:\n        - type: secret\n          id: pip\n          target: /etc/pip.conf\n</code></pre> <p>You can use secret mounts to securely pass credentials to setup commands, without baking them into the image. For more information, see Dockerfile reference.</p>"},{"location":"yaml/#sdk_version","title":"<code>sdk_version</code>","text":"<p>Pin the version of the cog Python SDK installed in the container. Accepts a PEP 440 version string. When omitted, the latest release is installed.</p> <pre><code>build:\n  python_version: \"3.12\"\n  sdk_version: \"0.18.0\"\n</code></pre> <p>Pre-release versions are also supported:</p> <pre><code>build:\n  sdk_version: \"0.18.0a1\"\n</code></pre> <p>When a pre-release <code>sdk_version</code> is set, <code>--pre</code> is automatically passed to the pip install commands for both <code>cog</code> and <code>coglet</code>, so pip will resolve matching pre-release packages.</p> <p>The minimum supported version is <code>0.16.0</code>. Specifying an older version will cause <code>cog build</code> to fail with an error.</p> <p>The <code>COG_SDK_WHEEL</code> environment variable takes precedence over <code>sdk_version</code>. See Environment variables for details.</p>"},{"location":"yaml/#system_packages","title":"<code>system_packages</code>","text":"<p>A list of Ubuntu APT packages to install. For example:</p> <pre><code>build:\n  system_packages:\n    - \"ffmpeg\"\n    - \"libavcodec-dev\"\n</code></pre>"},{"location":"yaml/#concurrency","title":"<code>concurrency</code>","text":"<p>Added in cog 0.14.0.</p> <p>This stanza describes the concurrency capabilities of the model. It has one option:</p>"},{"location":"yaml/#max","title":"<code>max</code>","text":"<p>The maximum number of concurrent predictions the model can process.  If this is set, the model must specify an async <code>predict()</code> method.</p> <p>For example:</p> <pre><code>concurrency:\n  max: 10\n</code></pre>"},{"location":"yaml/#image","title":"<code>image</code>","text":"<p>The name given to built Docker images. If you want to push to a registry, this should also include the registry name.</p> <p>For example:</p> <pre><code>image: \"r8.im/your-username/your-model\"\n</code></pre> <p>r8.im is Replicate's registry, but this can be any Docker registry.</p> <p>If you don't set this, then a name will be generated from the directory name.</p> <p>If you set this, then you can run <code>cog push</code> without specifying the model name. </p> <p>If you specify an image name argument when pushing (like <code>cog push your-username/custom-model-name</code>), the argument will be used and the value of <code>image</code> in cog.yaml will be ignored.</p>"},{"location":"yaml/#predict","title":"<code>predict</code>","text":"<p>The pointer to the <code>Predictor</code> object in your code, which defines how predictions are run on your model.</p> <p>For example:</p> <pre><code>predict: \"predict.py:Predictor\"\n</code></pre> <p>See the Python API documentation for more information.</p>"},{"location":"wsl2/wsl2/","title":"Using <code>cog</code> on Windows 11 with WSL 2","text":"<ul> <li>0. Prerequisites</li> <li>1. Install the GPU driver</li> <li>2. Unlocking features</li> <li>2.1. Unlock WSL2</li> <li>2.2. Unlock virtualization</li> <li>2.3. Reboot</li> <li>3. Update MS Linux kernel</li> <li>4. Configure WSL 2</li> <li>5. Configure CUDA WSL-Ubuntu Toolkit</li> <li>6. Install Docker</li> <li>7. Install <code>cog</code> and pull an image</li> <li>8. Run a model in WSL 2</li> <li>9. References</li> </ul> <p>Running cog on Windows is now possible thanks to WSL 2. Follow this guide to enable WSL 2 and GPU passthrough on Windows 11.</p> <p>Windows 10 is not officially supported, as you need to be on an insider build in order to use GPU passthrough.</p>"},{"location":"wsl2/wsl2/#0-prerequisites","title":"0. Prerequisites","text":"<p>Before beginning installation, make sure you have:</p> <ul> <li>Windows 11.</li> <li>NVIDIA GPU.</li> <li>RTX 2000/3000 series</li> <li>Kesler/Tesla/Volta/Ampere series</li> <li>Other configurations are not guaranteed to work.</li> </ul>"},{"location":"wsl2/wsl2/#1-install-the-gpu-driver","title":"1. Install the GPU driver","text":"<p>Per NVIDIA, the first order of business is to install the latest Game Ready drivers for your NVIDIA GPU.</p> <p>https://www.nvidia.com/download/index.aspx</p> <p>I have an NVIDIA RTX 2070 Super, so filled out the form as such:</p> <p></p> <p>Click \"search\", and follow the dialogue to download and install the driver.</p> <p>Restart your computer once the driver has finished installation.</p>"},{"location":"wsl2/wsl2/#2-unlocking-features","title":"2. Unlocking features","text":"<p>Open Windows Terminal as an administrator.</p> <ul> <li>Use start to search for \"Terminal\"</li> <li>Right click -&gt; Run as administrator...</li> </ul> <p>Run the following powershell command to enable the Windows Subsystem for Linux and Virtual Machine Platform capabilities.</p>"},{"location":"wsl2/wsl2/#21-unlock-wsl2","title":"2.1. Unlock WSL2","text":"<pre><code>dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n</code></pre> <p>If you see an error about permissions, make sure the terminal you are using is run as an administrator and that you have an account with administrator-level privileges.</p>"},{"location":"wsl2/wsl2/#22-unlock-virtualization","title":"2.2. Unlock virtualization","text":"<pre><code>dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n</code></pre> <p>If this command fails, make sure to enable virtualization capabilities in your computer's BIOS/UEFI. A successful output will print <code>The operation completed successfully.</code></p> <p></p>"},{"location":"wsl2/wsl2/#23-reboot","title":"2.3. Reboot","text":"<p>Before moving forward, make sure you reboot your computer so that Windows 11 will have WSL2 and virtualization available to it.</p>"},{"location":"wsl2/wsl2/#3-update-ms-linux-kernel","title":"3. Update MS Linux kernel","text":"<p>Download and run the WSL2 Linux kernel update package for x64 machines msi installer. When prompted for elevated permissions, click 'yes' to approve the installation.</p> <p>To ensure you are using the correct WSL kernel, <code>open Windows Terminal as an administrator</code> and enter:</p> <pre><code>wsl cat /proc/version\n</code></pre> <p>This will return a complicated string such as:</p> <pre><code>Linux version 5.10.102.1-microsoft-standard-WSL2 (oe-user@oe-host) (x86_64-msft-linux-gcc (GCC) 9.3.0, GNU ld (GNU Binutils) 2.34.0.20200220)\n</code></pre> <p>The version we are interested in is <code>Linux version 5.10.102.1</code>. At this point, you should have updated your kernel to be at least <code>Linux version 5.10.43.3</code>.</p> <p>If you can't get the correct kernel version to show:</p> <p>Open <code>Settings</code> \u2192 <code>Windows Update</code> \u2192 <code>Advanced options</code> and ensure <code>Receive updates for other Microsoft products</code> is enabled. Then go to <code>Windows Update</code> again and click <code>Check for updates</code>.</p>"},{"location":"wsl2/wsl2/#4-configure-wsl-2","title":"4. Configure WSL 2","text":"<p>First, configure Windows to use the virtualization-based version of WSL (version 2) by default. In a Windows Terminal with administrator privileges, type the following:</p> <pre><code>wsl --set-default-version 2\n</code></pre> <p>Now, you will need to go to the Microsoft Store and Download Ubuntu 18.04</p> <p></p> <p>Launch the \"Ubuntu\" app available in your Start Menu. Linux will require its own user account and password, which you will need to enter now:</p> <p></p>"},{"location":"wsl2/wsl2/#5-configure-cuda-wsl-ubuntu-toolkit","title":"5. Configure CUDA WSL-Ubuntu Toolkit","text":"<p>By default, a shimmed version of the CUDA tooling is provided by your Windows GPU drivers.</p> <p>Important: you should never use instructions for installing CUDA-toolkit in a generic linux fashion. in WSL 2, you always want to use the provided <code>CUDA Toolkit using WSL-Ubuntu Package</code>.</p> <p>First, open PowerShell or Windows Command Prompt in administrator mode by right-clicking and selecting \"Run as administrator\". Then enter the following command:</p> <pre><code>wsl.exe\n</code></pre> <p>This should drop you into your running linux VM. Now you can run the following bash commands to install the correct version of cuda-toolkit for WSL-Ubuntu. Note that the version of CUDA used below may not be the version of CUDA your GPU supports.</p> <pre><code>sudo apt-key del 7fa2af80 # if this line fails, you may remove it.\nwget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pin\nsudo mv cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600\nwget https://developer.download.nvidia.com/compute/cuda/11.7.0/local_installers/cuda-repo-wsl-ubuntu-11-7-local_11.7.0-1_amd64.deb\nsudo dpkg -i cuda-repo-wsl-ubuntu-11-7-local_11.7.0-1_amd64.deb\nsudo apt-get update\nsudo apt-get -y install cuda-toolkit-11-7\n</code></pre>"},{"location":"wsl2/wsl2/#6-install-docker","title":"6. Install Docker","text":"<p>Download and install Docker Desktop for Windows. It has WSL 2 support built in by default.</p> <p>Once installed, run <code>Docker Desktop</code>, you can ignore the first-run tutorial. Go to Settings \u2192 General and ensure Use the WSL 2 based engine has a checkmark next to it. Click Apply &amp; Restart.</p> <p></p> <p>Reboot your computer one more time.</p>"},{"location":"wsl2/wsl2/#7-install-cog-and-pull-an-image","title":"7. Install <code>cog</code> and pull an image","text":"<p>Open Windows Terminal and enter your WSL 2 VM:</p> <pre><code>wsl.exe\n</code></pre> <p>Download and install <code>cog</code> inside the VM:</p> <pre><code>sudo curl -o /usr/local/bin/cog -L https://github.com/replicate/cog/releases/latest/download/cog_`uname -s`_`uname -m`\nsudo chmod +x /usr/local/bin/cog\n</code></pre> <p>Make sure it's available by typing:</p> <pre><code>which cog # should output /usr/local/bin/cog\ncog --version # should output the cog version number.\n</code></pre>"},{"location":"wsl2/wsl2/#8-run-a-model-in-wsl-2","title":"8. Run a model in WSL 2","text":"<p>Finally, make sure it works. Let's try running <code>afiaka87/glid-3-xl</code> locally:</p> <pre><code>cog predict 'r8.im/afiaka87/glid-3-xl' -i prompt=\"a fresh avocado floating in the water\" -o prediction.json\n</code></pre> <p></p> <p>While your prediction is running, you can use <code>Task Manager</code> to keep an eye on GPU memory consumption:</p> <p></p> <p>This model just barely manages to fit under 8 GB of VRAM.</p> <p>Notice that output is returned as JSON for this model as it has a complex return type. You will want to convert the base64 string in the json array to an image.</p> <p><code>jq</code> can help with this:</p> <pre><code>sudo apt install jq\n</code></pre> <p>The following bash uses <code>jq</code> to grab the first element in our prediction array and converts it from a base64 string to a <code>png</code> file.</p> <pre><code>jq -cs '.[0][0][0]' prediction.json | cut --delimiter \",\" --field 2 | base64 --ignore-garbage --decode &gt; prediction.png\n</code></pre> <p>When using WSL 2, you can access Windows binaries with the <code>.exe</code> extension. This lets you open photos easily within linux.</p> <pre><code>explorer.exe prediction.png\n</code></pre> <p></p>"},{"location":"wsl2/wsl2/#9-references","title":"9. References","text":"<ul> <li>https://docs.nvidia.com/cuda/wsl-user-guide/index.html</li> <li>https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=WSL-Ubuntu&amp;target_version=2.0</li> <li>https://www.docker.com/blog/wsl-2-gpu-support-for-docker-desktop-on-nvidia-gpus/</li> <li>https://docs.microsoft.com/en-us/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package</li> <li>https://github.com/replicate/cog</li> </ul>"}]}