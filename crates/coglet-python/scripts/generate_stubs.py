#!/usr/bin/env python3
"""Generate type stubs for the coglet native module.

This script introspects the built coglet module and generates a .pyi stub file.
Run after building the module with `mise run build:coglet`.

Usage:
    python scripts/generate_stubs.py > coglet.pyi
    # Or to check for differences:
    python scripts/generate_stubs.py --check
"""

import argparse
import inspect
import sys
from typing import Any, Callable, TextIO


HEADER = '''\
"""Type stubs for the coglet native module.

coglet is the Rust execution engine for cog models. It runs predictions
in a subprocess with IPC for crash isolation and memory isolation.

This file is auto-generated by scripts/generate_stubs.py.
Do not edit manually - regenerate with: mise run stubs:generate
"""

from typing import Any, Optional

'''

# Docstrings for public API (internal functions get minimal docs)
DOCSTRINGS = {
    "__version__": None,  # Just a type annotation
    "active": '''\
    """Check if running inside a worker subprocess.

    Returns:
        True when running inside the worker subprocess (after coglet._run_worker()),
        False in the parent process (when calling coglet.serve()).
    """\
''',
    "serve": '''\
    """Start the coglet HTTP server.

    Args:
        predictor_ref: Path to predictor like "predict.py:Predictor".
                       If None, only health endpoints are served.
        host: Host to bind to.
        port: Port to listen on.
        await_explicit_shutdown: If True, ignore SIGTERM and wait for
                                  SIGINT or /shutdown endpoint.
        is_train: If True, call train() instead of predict().
    """\
''',
    "_run_worker": '''\
    """Internal: Run as a worker subprocess.

    Called by the orchestrator via:
        python -c "import coglet; coglet._run_worker()"

    Reads Init message from stdin, runs setup, then processes predictions.
    Do not call directly.
    """\
''',
    "_is_cancelable": '''\
    """Internal: Check if we're in a cancelable section.

    Used by Python signal handlers for cancellation.
    """\
''',
}


def get_signature(obj: Callable[..., Any]) -> str | None:
    """Get the signature string for a callable."""
    try:
        sig = inspect.signature(obj)
        # Convert Ellipsis default to actual string value
        params = []
        for name, param in sig.parameters.items():
            if param.default is ...:
                # PyO3 uses Ellipsis for string defaults, get actual from introspection
                params.append(
                    f'{name}: str = "0.0.0.0"'
                    if name == "host"
                    else f"{name}={param.default!r}"
                )
            elif param.default is inspect.Parameter.empty:
                params.append(name)
            else:
                params.append(f"{name}={param.default!r}")
        return f"({', '.join(params)})"
    except (ValueError, TypeError):
        return None


def format_function(name: str, obj: Callable[..., Any]) -> str:
    """Format a function as a stub definition."""
    sig = get_signature(obj)
    if sig is None:
        sig = "(*args, **kwargs)"

    # Fix known signatures from PyO3
    if name == "serve":
        sig = '(\n    predictor_ref: Optional[str] = None,\n    host: str = "0.0.0.0",\n    port: int = 5000,\n    await_explicit_shutdown: bool = False,\n    is_train: bool = False,\n)'
        ret = " -> None"
    elif name == "active":
        sig = "()"
        ret = " -> bool"
    elif name == "_run_worker":
        sig = "()"
        ret = " -> None"
    elif name == "_is_cancelable":
        sig = "()"
        ret = " -> bool"
    elif name == "_is_slot_log_writer":
        sig = "(value: Any)"
        ret = " -> bool"
    elif name == "_is_tee_writer":
        sig = "(value: Any)"
        ret = " -> bool"
    elif name == "_get_inner_writer":
        sig = "(tee: TeeWriter)"
        ret = " -> Any"
    elif name == "_create_tee_writer":
        sig = "(inner: Any, user_stream: Any, name: str)"
        ret = " -> TeeWriter"
    else:
        ret = " -> Any"

    doc = DOCSTRINGS.get(name, f'    """Internal function."""')
    if doc:
        return f"def {name}{sig}{ret}:\n{doc}\n    ..."
    return f"def {name}{sig}{ret}: ..."


def format_class(name: str, cls: type) -> str:
    """Format a class as a stub definition."""
    if name == "SlotLogWriter":
        return '''\
class SlotLogWriter:
    """Internal: Log writer that routes output based on prediction context.
    
    Do not instantiate directly.
    """
    def write(self, data: str) -> int: ...
    def flush(self) -> None: ...\
'''
    elif name == "TeeWriter":
        return '''\
class TeeWriter:
    """Internal: Writer that tees output to both coglet and user stream.
    
    Do not instantiate directly.
    """
    def write(self, data: str) -> int: ...
    def flush(self) -> None: ...\
'''
    return f"class {name}: ..."


def generate_stubs(out: TextIO) -> None:
    """Generate stub file content."""
    import coglet

    out.write(HEADER)

    # Module version
    out.write("# Module version\n")
    out.write("__version__: str\n\n")

    # Collect items by type
    functions = []
    classes = []

    for name in sorted(dir(coglet)):
        if name.startswith("__") or name == "coglet":
            continue

        obj = getattr(coglet, name)

        if isinstance(obj, type):
            classes.append((name, obj))
        elif callable(obj):
            functions.append((name, obj))

    # Output classes first (TeeWriter referenced by functions)
    if classes:
        out.write("# Classes\n\n")
        for name, cls in classes:
            out.write(format_class(name, cls))
            out.write("\n\n")

    # Output functions
    out.write("# Functions\n\n")

    # Public functions first
    public_funcs = [(n, o) for n, o in functions if not n.startswith("_")]
    private_funcs = [(n, o) for n, o in functions if n.startswith("_")]

    for name, obj in public_funcs:
        out.write(format_function(name, obj))
        out.write("\n\n")

    if private_funcs:
        out.write("# Internal functions (do not use directly)\n\n")
        for name, obj in private_funcs:
            out.write(format_function(name, obj))
            out.write("\n\n")


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate coglet type stubs")
    parser.add_argument(
        "--check", action="store_true", help="Check if stubs are up to date"
    )
    parser.add_argument("--output", "-o", help="Output file (default: stdout)")
    args = parser.parse_args()

    import io

    buf = io.StringIO()
    generate_stubs(buf)
    generated = buf.getvalue().rstrip() + "\n"

    if args.check:
        import pathlib

        stub_path = pathlib.Path(__file__).parent.parent / "coglet.pyi"
        if not stub_path.exists():
            print(f"ERROR: Stub file not found: {stub_path}", file=sys.stderr)
            return 1

        existing = stub_path.read_text()
        if existing != generated:
            print(
                "ERROR: Stubs are out of date. Run 'mise run stubs:generate' to update.",
                file=sys.stderr,
            )
            print("\nDiff:", file=sys.stderr)
            import difflib

            diff = difflib.unified_diff(
                existing.splitlines(keepends=True),
                generated.splitlines(keepends=True),
                fromfile="coglet.pyi (existing)",
                tofile="coglet.pyi (generated)",
            )
            sys.stderr.writelines(diff)
            return 1

        print("Stubs are up to date.")
        return 0

    if args.output:
        with open(args.output, "w") as f:
            f.write(generated)
        print(f"Wrote {args.output}", file=sys.stderr)
    else:
        sys.stdout.write(generated)

    return 0


if __name__ == "__main__":
    sys.exit(main())
