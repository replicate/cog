# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401, F403, F405

import builtins
import typing
__all__ = []

@typing.final
class _SlotLogWriter:
    r"""
    A Python file-like object that routes writes via the prediction_id ContextVar.
    
    This is installed as sys.stdout/stderr once at worker startup.
    Each write looks up the current prediction_id from the ContextVar and routes
    to the appropriate SlotSender.
    
    If no prediction_id is set, or the prediction has completed (orphan task),
    writes go to tracing (logged as orphan).
    
    Uses line buffering: accumulates writes until a newline is received, then
    emits complete lines. This coalesces Python's print() which does separate
    writes for content and newline.
    """
    @property
    def closed(self) -> builtins.bool:
        r"""
        Whether writes should be ignored (used after errors).
        """
    @property
    def encoding(self) -> typing.Optional[builtins.str]:
        r"""
        Encoding property - needed for compatibility.
        """
    @property
    def newlines(self) -> typing.Optional[builtins.str]:
        r"""
        Newlines property - needed for compatibility.
        """
    @property
    def buffer(self) -> typing.Any:
        r"""
        Buffer property - some code checks for this.
        """
    def write(self, data: builtins.str) -> builtins.int:
        r"""
        Write data, routing to the appropriate destination.
        
        Uses line buffering: accumulates data until a newline is received, then
        emits complete lines. This coalesces Python's print() which does separate
        writes for content and the trailing newline.
        
        Priority for routing:
        1. If inside a prediction (ContextVar set), route to slot sender
        2. If setup sender registered, route to control channel  
        3. Fall back to stderr (for orphan tasks or unexpected cases)
        """
    def emit_data(self, data: builtins.str) -> None:
        r"""
        Emit data to the appropriate destination.
        """
    def flush(self) -> None:
        r"""
        Flush the stream.
        
        Emits any buffered content that hasn't been terminated with a newline.
        """
    def readable(self) -> builtins.bool:
        r"""
        Return whether the stream is readable.
        """
    def writable(self) -> builtins.bool:
        r"""
        Return whether the stream is writable.
        """
    def seekable(self) -> builtins.bool:
        r"""
        Return whether the stream is seekable.
        """
    def isatty(self) -> builtins.bool:
        r"""
        Return whether the stream is a TTY.
        """
    def fileno(self) -> builtins.int:
        r"""
        Return the file number.
        """
    def close(self) -> None:
        r"""
        Close the stream.
        """
    def __enter__(self) -> _SlotLogWriter:
        r"""
        Context manager enter.
        """
    def __exit__(self, _exc_type: typing.Optional[typing.Any], _exc_val: typing.Optional[typing.Any], _exc_tb: typing.Optional[typing.Any]) -> builtins.bool:
        r"""
        Context manager exit.
        """

@typing.final
class _TeeWriter:
    r"""
    Tee writer that sends writes to both our slot routing and user's stream.
    
    - inner: Our _SlotLogWriter for slot-based log routing
    - user_stream: The stream user code tried to install
    """
    @property
    def inner(self) -> typing.Any:
        r"""
        Our _SlotLogWriter (does ContextVar-based routing)
        """
    @property
    def user_stream(self) -> typing.Any:
        r"""
        User's replacement stream
        """
    @property
    def name(self) -> builtins.str:
        r"""
        Stream name (stdout or stderr)
        """
    @property
    def closed(self) -> builtins.bool:
        r"""
        Closed flag
        """
    @property
    def encoding(self) -> typing.Optional[builtins.str]: ...
    @property
    def newlines(self) -> typing.Optional[builtins.str]: ...
    def __new__(cls, inner: typing.Any, user_stream: typing.Any, name: builtins.str) -> _TeeWriter: ...
    def write(self, data: builtins.str) -> builtins.int:
        r"""
        Write to both streams.
        """
    def flush(self) -> None:
        r"""
        Flush both streams.
        """
    def readable(self) -> builtins.bool: ...
    def writable(self) -> builtins.bool: ...
    def seekable(self) -> builtins.bool: ...
    def isatty(self) -> builtins.bool: ...
    def fileno(self) -> builtins.int: ...
    def close(self) -> None: ...
    def __enter__(self) -> _TeeWriter: ...
    def __exit__(self, _exc_type: typing.Optional[typing.Any], _exc_val: typing.Optional[typing.Any], _exc_tb: typing.Optional[typing.Any]) -> builtins.bool: ...

