# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401, F403, F405

import builtins
import typing
__all__ = [
    "SlotLogWriter",
    "TeeWriter",
    "active",
    "serve",
]

@typing.final
class SlotLogWriter:
    r"""
    A Python file-like object that routes writes via the prediction_id ContextVar.
    
    This is installed as sys.stdout/stderr once at worker startup.
    Each write looks up the current prediction_id from the ContextVar and routes
    to the appropriate SlotSender.
    
    If no prediction_id is set, or the prediction has completed (orphan task),
    writes go to tracing (logged as orphan).
    
    Uses line buffering: accumulates writes until a newline is received, then
    emits complete lines. This coalesces Python's print() which does separate
    writes for content and newline.
    """
    @property
    def closed(self) -> builtins.bool:
        r"""
        Whether writes should be ignored (used after errors).
        """
    @property
    def encoding(self) -> typing.Optional[builtins.str]:
        r"""
        Encoding property - needed for compatibility.
        """
    @property
    def newlines(self) -> typing.Optional[builtins.str]:
        r"""
        Newlines property - needed for compatibility.
        """
    @property
    def buffer(self) -> typing.Any:
        r"""
        Buffer property - some code checks for this.
        """
    def write(self, data: builtins.str) -> builtins.int:
        r"""
        Write data, routing to the appropriate destination.
        
        Uses line buffering: accumulates data until a newline is received, then
        emits complete lines. This coalesces Python's print() which does separate
        writes for content and the trailing newline.
        
        Priority for routing:
        1. If inside a prediction (ContextVar set), route to slot sender
        2. If setup sender registered, route to control channel  
        3. Fall back to stderr (for orphan tasks or unexpected cases)
        """
    def emit_data(self, data: builtins.str) -> None:
        r"""
        Emit data to the appropriate destination.
        """
    def flush(self) -> None:
        r"""
        Flush the stream.
        
        Emits any buffered content that hasn't been terminated with a newline.
        """
    def readable(self) -> builtins.bool:
        r"""
        Return whether the stream is readable.
        """
    def writable(self) -> builtins.bool:
        r"""
        Return whether the stream is writable.
        """
    def seekable(self) -> builtins.bool:
        r"""
        Return whether the stream is seekable.
        """
    def isatty(self) -> builtins.bool:
        r"""
        Return whether the stream is a TTY.
        """
    def fileno(self) -> builtins.int:
        r"""
        Return the file number.
        """
    def close(self) -> None:
        r"""
        Close the stream.
        """
    def __enter__(self) -> SlotLogWriter:
        r"""
        Context manager enter.
        """
    def __exit__(self, _exc_type: typing.Optional[typing.Any], _exc_val: typing.Optional[typing.Any], _exc_tb: typing.Optional[typing.Any]) -> builtins.bool:
        r"""
        Context manager exit.
        """

@typing.final
class TeeWriter:
    r"""
    TeeWriter that sends writes to both our slot routing and user's stream.
    
    This is a PyO3 class that wraps two writers:
    - inner: Our SlotLogWriter for slot routing
    - user_stream: The stream user code tried to install
    """
    @property
    def inner(self) -> typing.Any:
        r"""
        Our SlotLogWriter (does ContextVar-based routing)
        """
    @property
    def user_stream(self) -> typing.Any:
        r"""
        User's replacement stream
        """
    @property
    def name(self) -> builtins.str:
        r"""
        Stream name (stdout or stderr)
        """
    @property
    def closed(self) -> builtins.bool:
        r"""
        Closed flag
        """
    @property
    def encoding(self) -> typing.Optional[builtins.str]: ...
    @property
    def newlines(self) -> typing.Optional[builtins.str]: ...
    def __new__(cls, inner: typing.Any, user_stream: typing.Any, name: builtins.str) -> TeeWriter: ...
    def write(self, data: builtins.str) -> builtins.int:
        r"""
        Write to both streams.
        """
    def flush(self) -> None:
        r"""
        Flush both streams.
        """
    def readable(self) -> builtins.bool: ...
    def writable(self) -> builtins.bool: ...
    def seekable(self) -> builtins.bool: ...
    def isatty(self) -> builtins.bool: ...
    def fileno(self) -> builtins.int: ...
    def close(self) -> None: ...
    def __enter__(self) -> TeeWriter: ...
    def __exit__(self, _exc_type: typing.Optional[typing.Any], _exc_val: typing.Optional[typing.Any], _exc_tb: typing.Optional[typing.Any]) -> builtins.bool: ...

def _create_tee_writer(inner: typing.Any, user_stream: typing.Any, name: builtins.str) -> TeeWriter:
    r"""
    Create a TeeWriter that wraps our SlotLogWriter and user's stream.
    """

def _get_inner_writer(tee: typing.Any) -> typing.Any:
    r"""
    Get the inner SlotLogWriter from a TeeWriter.
    """

def _is_cancelable() -> builtins.bool: ...

def _is_slot_log_writer(value: typing.Any) -> builtins.bool:
    r"""
    Check if a value is a SlotLogWriter (our core writer).
    """

def _is_tee_writer(value: typing.Any) -> builtins.bool:
    r"""
    Check if a value is a TeeWriter.
    """

def _run_worker() -> None: ...

def active() -> builtins.bool: ...

def serve(predictor_ref: typing.Optional[builtins.str] = None, host: builtins.str = '0.0.0.0', port: builtins.int = 5000, await_explicit_shutdown: builtins.bool = False, is_train: builtins.bool = False) -> None: ...

