//! Generate Python stub files for coglet.
//!
//! Run with: cargo run --bin stub_gen
//!
//! Custom generate logic: pyo3-stub-gen places classes from the native
//! `coglet._impl` module into the `coglet` parent package, but mypy stubgen
//! overwrites `coglet/__init__.pyi` from the hand-maintained `__init__.py`.
//! We redirect the `coglet` module output to `coglet/_impl.pyi` so the
//! native module types are preserved, and also generate `coglet/__init__.pyi`
//! to re-export the public API.

use pyo3_stub_gen::Result;
use std::fs;
use std::io::Write;

/// Items re-exported from `coglet._impl` in `coglet/__init__.py`.
///
/// Public items use the `as X` pattern to mark them as explicit re-exports
/// for type checkers (PEP 484). `_sdk` is re-exported with `as _sdk` so
/// the cog SDK can import it, but it is NOT included in `__all__` because
/// it is an internal/private submodule.
const PUBLIC_REEXPORTS: &[&str] = &["__build__", "__version__", "server", "CancelationException"];
const PRIVATE_REEXPORTS: &[&str] = &["_sdk"];

fn main() -> Result<()> {
    let stub = coglet::stub_info()?;

    for (name, module) in &stub.modules {
        let normalized = name.replace('-', "_");

        let dest = if normalized == "coglet" {
            // Native module classes land here — redirect to _impl.pyi
            stub.python_root.join("coglet").join("_impl.pyi")
        } else {
            // Submodules like "coglet._sdk" → coglet/_sdk/__init__.pyi
            let path = normalized.replace('.', "/");
            stub.python_root.join(&path).join("__init__.pyi")
        };

        let dir = dest.parent().expect("cannot get parent directory");
        if !dir.exists() {
            fs::create_dir_all(dir)?;
        }

        let mut f = fs::File::create(&dest)?;
        write!(f, "{module}")?;
        eprintln!("Generated stub: {}", dest.display());
    }

    // Generate coglet/__init__.pyi — re-exports from _impl
    let init_pyi = stub.python_root.join("coglet").join("__init__.pyi");
    let mut f = fs::File::create(&init_pyi)?;

    writeln!(f, "# This file is automatically generated by stub_gen")?;
    writeln!(f, "# ruff: noqa: E501, F401")?;
    writeln!(f)?;

    // Build the import line: `from coglet._impl import X as X, Y as Y, ...`
    let all_reexports: Vec<String> = PUBLIC_REEXPORTS
        .iter()
        .chain(PRIVATE_REEXPORTS.iter())
        .map(|name| format!("{name} as {name}"))
        .collect();
    writeln!(f, "from coglet._impl import {}", all_reexports.join(", "))?;
    writeln!(f)?;

    // __all__ only includes public items (no underscore-prefixed names)
    let all_items: Vec<String> = PUBLIC_REEXPORTS
        .iter()
        .map(|name| format!("'{name}'"))
        .collect();
    writeln!(f, "__all__ = [{}]", all_items.join(", "))?;

    eprintln!("Generated stub: {}", init_pyi.display());

    Ok(())
}
