[fast] skip 'slow test - skip in fast mode'

# Test double fork subprocess spawned during setup
# This ensures stream redirection works correctly with daemonized processes

# Build the image
cog build -t $TEST_IMAGE

# Start the server
cog serve

# Make predictions that communicate via file system with forked process
# Use generous retries since setup spawns a double-forked process
retry-curl POST /predictions '{"input":{"s":"friendo1"}}' 30 1s
stdout '"output":"hello friendo1"'

retry-curl POST /predictions '{"input":{"s":"friendo2"}}' 10 500ms
stdout '"output":"hello friendo2"'

retry-curl POST /predictions '{"input":{"s":"friendo3"}}' 10 500ms
stdout '"output":"hello friendo3"'

-- cog.yaml --
build:
  python_version: "3.12"
predict: "predict.py:Predictor"

-- predict.py --
import os.path
import signal
import subprocess
import sys
import time

from cog import BasePredictor


class Predictor(BasePredictor):
    """
    This predictor checks the case where a process is spawned during setup and then each
    prediction depends on being able to communicate with that process. In the event that
    stream redirection is not working correctly, the forked process will not be able to
    write to stdout/stderr and will likely exit. Any state other than "running" is
    considered an error condition and raises SystemExit to interrupt any more prediction
    serving.

    This variant runs a forked python process via a shell wrapper to which a "message" is
    sent via file for each call to `predict`.
    """

    def setup(self) -> None:
        print("---> starting background process")

        self.bg = subprocess.Popen(["bash", "run-forker.sh"])

        print(f"---> started background process pid={self.bg.pid}")

    def predict(self, s: str) -> str:
        status = self.bg.poll()

        print(f"---> background job status={status}")

        if status is not None:
            raise SystemExit

        print(f"---> sending message to background job pid={self.bg.pid}")

        with open(".inbox", "w") as inbox:
            inbox.write(s)

        print(f"---> sent message to background job pid={self.bg.pid}")

        now = time.time()

        print(f"---> waiting for outbox message from background job pid={self.bg.pid}")

        while not os.path.exists(".outbox"):
            if time.time() - now > 5:
                raise TimeoutError

            time.sleep(0.01)

        try:
            with open(".outbox", "r") as outbox:
                print(f"---> relaying message from background job pid={self.bg.pid}")

                return outbox.read()

        finally:
            os.unlink(".outbox")

-- run-forker.sh --
#!/usr/bin/env bash
python ./forker.py &
wait

-- forker.py --
import os
import signal
import time


def main():
    child_pid = os.fork()
    is_child = child_pid == 0

    pid = os.getpid()
    was_pinged = False

    while True:
        if os.path.exists(".inbox") and is_child:
            s = ""

            with open(".inbox", "r") as inbox:
                print(f"---> CHILD ({pid}) reading request")

                s = inbox.read()

            os.unlink(".inbox")

            with open(".outbox", "w") as outbox:
                print(f"---> CHILD ({pid}) sending response")

                outbox.write("hello " + s)

        if time.time() % 10 == 0:
            if is_child:
                print(f"---> CHILD ({pid}) " + ("here " * 20))
            else:
                print(f"===> PARENT ({pid})")

        time.sleep(0.01)


if __name__ == "__main__":
    main()
